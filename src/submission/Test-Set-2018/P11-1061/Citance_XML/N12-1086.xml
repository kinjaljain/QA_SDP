<PAPER>
	<S sid="0">Graph-Based Lexicon Expansion with Sparsity-Inducing Penalties</S><ABSTRACT>
		<S sid="1" ssid="1">We present novel methods to construct compact natural language lexicons within a graph based semi-supervised learning framework, an attractive platform suited for propagating soft labels onto new natural language types from seed data.</S>
		<S sid="2" ssid="2">To achieve compactness, we induce sparse measures at graph vertices by incorporating sparsity-inducing penalties in Gaussian and entropic pairwise Markovnetworks constructed from labeled and unla beled data.</S>
		<S sid="3" ssid="3">Sparse measures are desirable forhigh-dimensional multi-class learning problems such as the induction of labels on natu ral language types, which typically associate with only a few labels.</S>
		<S sid="4" ssid="4">Compared to standard graph-based learning methods, for two lexicon expansion problems, our approach producessignificantly smaller lexicons and obtains bet ter predictive performance.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number="1">
			<S sid="5" ssid="5">Semi-supervised learning (SSL) is attractive for thelearning of complex phenomena, for example, linguistic structure, where data annotation is expen sive.</S>
			<S sid="6" ssid="6">Natural language processing applications havebenefited from various SSL techniques, such as dis tributional word representations (Huang and Yates, 2009; Turian et al, 2010; Dhillon et al, 2011), self-training (McClosky et al, 2006), and entropy regularization (Jiao et al, 2006; Smith and Eisner, 2007).</S>
			<S sid="7" ssid="7">In this paper, we focus on semi-supervised learning that uses a graph constructed from labeled and unlabeled data.</S>
			<S sid="8" ssid="8">This framework, graph-based SSL?see Bengio et al (2006) and Zhu (2008) for introductory material on this topic?has been widelyused and has been shown to perform better than sev eral other semi-supervised algorithms on benchmark datasets (Chapelle et al, 2006, ch.</S>
			<S sid="9" ssid="9">21).</S>
			<S sid="10" ssid="10">The methodconstructs a graph where a small portion of ver tices correspond to labeled instances, and the rest are unlabeled.</S>
			<S sid="11" ssid="11">Pairs of vertices are connected by weighted edges denoting the similarity between thepair.</S>
			<S sid="12" ssid="12">Traditionally, Markov random walks (Szummer and Jaakkola, 2001; Baluja et al, 2008) or op timization of a loss function based on smoothness properties of the graph (Corduneanu and Jaakkola, 2003; Zhu et al, 2003; Subramanya and Bilmes, 2008, inter alia) are performed to propagate labels from the labeled vertices to the unlabeled ones.In this work, we are interested in multi-class generalizations of graph-propagation algorithms suitable for NLP applications, where each graph ver tex can assume one or more out of many possible labels (Talukdar and Crammer, 2009; Subramanyaand Bilmes, 2008, 2009).</S>
			<S sid="13" ssid="13">For us, graph vertices cor respond to natural language types (not tokens) and undirected edges between them are weighted using a similarity metric.</S>
			<S sid="14" ssid="14">Recently, this setup has been used to learn soft labels on natural language types (say,word n-grams or syntactically disambiguated pred icates) from seed data, resulting in large but noisylexicons, which are used to constrain structured pre diction models.</S>
			<S sid="15" ssid="15">Applications have ranged from domain adaptation of part-of-speech (POS) taggers (Subramanya et al, 2010), unsupervised learning ofPOS taggers by using bilingual graph-based projections (Das and Petrov, 2011), and shallow seman tic parsing for unknown predicates (Das and Smith,2011).</S>
			<S sid="16" ssid="16">However, none of the above captured the empirical fact that only a few categories typically asso ciate with a given type (vertex).</S>
			<S sid="17" ssid="17">Take the case of POS tagging: Subramanya et al (2010) construct agraph over trigram types as vertices, with 45 pos sible tags for the middle word of a trigram as the 677 label set for each vertex.</S>
			<S sid="18" ssid="18">It is empirically observed that contextualized word types can assume very few (most often, one) POS tags.</S>
			<S sid="19" ssid="19">However, along with graph smoothness terms, they apply a penalty that encourages distributions to be close to uniform, the premise being that it would maximize the entropy of the distribution for a vertex that is far away ordisconnected from a labeled vertex.</S>
			<S sid="20" ssid="20">To prefer maxi mum entropy solutions in low confidence regions ofgraphs, a similar entropic penalty is applied by Sub ramanya and Bilmes (2008, 2009).In this paper, we make two major algorithmic con tributions.</S>
			<S sid="21" ssid="21">First, we relax the assumption made by most previous work (Zhu and Ghahramani, 2002; Baluja et al, 2008; Subramanya and Bilmes, 2008; Subramanya and Bilmes, 2009; Subramanya et al, 2010; Das and Petrov, 2011; Das and Smith, 2011)that the `1 norm of the masses assigned to the la bels for a given vertex must be 1.</S>
			<S sid="22" ssid="22">In other words,in our framework, the label distribution at each ver tex is unnormalized?the only constraint we put onthe vertices?</S>
			<S sid="23" ssid="23">vectors is that they must be nonnega tive.1 This relaxation simplifies optimization: since only a nonnegativity constraint for each label?s mass at each vertex needs to be imposed, we can apply a generic quasi-Newton method (Zhu et al, 1997).Second, we replace the penalties that prefer max imum entropy, used in prior work, with penalties that aim to identify sparse unnormalized measures at each graph vertex.</S>
			<S sid="24" ssid="24">We achieve this by penalizing the graph propagation objective with the `1 norm or the mixed `1,2 norm (Kowalski and Torre?sani, 2009) of the measures at each vertex, aiming for global and vertex-level sparsity, respectively.</S>
			<S sid="25" ssid="25">Importantly, the proposed graph objective functions are convex, so we avoid degenerate solutions and local minima.</S>
			<S sid="26" ssid="26">We present experiments on two natural language lexicon expansion problems in a semi-supervised setting: (i) inducing distributions of POS tags over n-gram types in the Wall Street Journal section of the Penn Treebank corpus (Marcus et al, 1993) and (ii) inducing distributions of semantic frames(Fillmore, 1982) over predicates unseen in anno 1Moreover, we also assume the edge weights in a givengraph are unconstrained, consistent with prior work on graphbased SSL (Das and Petrov, 2011; Das and Smith, 2011; Subramanya and Bilmes, 2008; Subramanya and Bilmes, 2009; Sub ramanya et al, 2010; Zhu and Ghahramani, 2002).</S>
			<S sid="27" ssid="27">tated data.</S>
			<S sid="28" ssid="28">Our methods produce sparse measures at graph vertices resulting in compact lexicons, andalso result in better performance with respect to la bel propagation using Gaussian penalties (Zhu andGhahramani, 2002) and entropic measure propagation (Subramanya and Bilmes, 2009), two state-of the-art graph propagation algorithms.</S>
	</SECTION>
	<SECTION title="Model. " number="2">
			<S sid="29" ssid="1">2.1 Graph-Based SSL as MAP Inference.</S>
			<S sid="30" ssid="2">Let Dl = {(xj , rj)}lj=1 denote l annotated data types;2 xj?s empirical label distribution is rj . Let the unlabeled data types be denoted by Du = {xi}mi=l+1.</S>
			<S sid="31" ssid="3">Usually, l  m. Thus, the entire dataset can be called D , Dl ? Du.</S>
			<S sid="32" ssid="4">Traditionally, thegraph-based SSL problem has been set up as fol lows.</S>
			<S sid="33" ssid="5">Let G = (V,E) correspond to an undirected graph with vertices V and edges E. G is constructedby transforming each data type xi ? D to a ver tex; thus V = {1, 2, . . .</S>
			<S sid="34" ssid="6">,m}, and E ? V ? V . Let Vl (Vu) denote the labeled (unlabeled) vertices.</S>
			<S sid="35" ssid="7">Moreover, we assume a symmetric weight matrixW that defines the similarity between a pair of verticesi, k ? V . We first define a component of this ma trix as wij , [W]ik = sim(xi,xk).</S>
			<S sid="36" ssid="8">We also fix wii = 0 and set wik = wki = 0 if k 6?</S>
			<S sid="37" ssid="9">N (i) and i 6?</S>
			<S sid="38" ssid="10">N (k), where N (j) denotes the K-nearest neighbors of vertex j, to reduce the density of the graph.</S>
			<S sid="39" ssid="11">We next define an unnormalized measure qi for every vertex i ? V . As mentioned before, we have rj , a probability distribution estimated from annotated data for a labeled vertex j ? Vl.</S>
			<S sid="40" ssid="12">qi and rj are |Y |-dimensional measures, where Y is thepossible set of labels; while rj lies within the |Y |dimensional probability simplex,3 qi are unnormal ized with each component qi(y) ? 0.</S>
			<S sid="41" ssid="13">For most NLP problems, rj are expected to be sparse, with very few components active, the rest being zero.</S>
			<S sid="42" ssid="14">Graph-based SSL aims at finding the best q ={qi : 1 ? i ? m} given the empirical distribu tions rj , and the weight matrix W, which provides 2As explained in more detail in ?4, these types are entities like n-grams or individual predicates, not tokens in running text.</S>
			<S sid="43" ssid="15">3Note that our framework does not necessitate that rj be anormalized probability distribution; we could have unnormal ized rj to allow strongly evident types appearing in more data to have larger influence than types that appear infrequently.</S>
			<S sid="44" ssid="16">We leave this extension to future work.</S>
			<S sid="45" ssid="17">678 the geometry of all the vertices.</S>
			<S sid="46" ssid="18">We visualize this problem using a pairwise Markov network (MN).</S>
			<S sid="47" ssid="19">For every vertex (including labeled ones) i ? V , wecreate a variable Xi.</S>
			<S sid="48" ssid="20">Additionally, for labeled ver tices j ? Vl, we create variables X?j . All variables in the MN are defined to be vector-valued; specifically, variables Xi, ?i ? V , take value qi, and variablesX?j corresponding to the labeled vertices in G are ob served with values rj . An example factor graph forthis MN, with only four vertices, is shown in Fig ure 1.</S>
			<S sid="49" ssid="21">In the figure, the variables indexed by 1 and 4 correspond to labeled vertices.</S>
			<S sid="50" ssid="22">Factor ?j with scope {Xj , X?j} encourages qj to be close to rj . For every edge i ? k ? E, factor ?i?k encourages similarity between qi and qk, making use of the weight matrix W (i.e., when wik is larger, the two measures aremore strongly encouraged to be close).</S>
			<S sid="51" ssid="23">These fac tors are white squares with solid boundaries in thefigure.</S>
			<S sid="52" ssid="24">Finally, we define unary factors on all vari ablesXi, i ? V , named ?i(Xi), that can incorporateprior information.</S>
			<S sid="53" ssid="25">In Figure 1, these factors are rep resented by white squares with dashed boundaries.According to the factor graph, the joint probabil ity for all the measures qi, ?i ? V that we want to induce, is defined as: P (X; ?) = 1 Z l?</S>
			<S sid="54" ssid="26">j=1 ?j(Xj , X?j) ? ?</S>
			<S sid="55" ssid="27">i?k?E ?i?k(Xi, Xk) ? m? i=1 ?i(Xi) where ? is the set of all factors in the factor graph,and Z is a partition function that normalizes the fac tor products for a given configuration of q. Since the graph-based SSL problem aims at finding the best q, we optimize lnP (X; ?); equivalently, arg max q s.t. q?0 l?</S>
			<S sid="56" ssid="28">j=1 ln?j(Xj , X?j) + ? i?k?E ln?i?k(Xi, Xk) + m?</S>
			<S sid="57" ssid="29">i=1 ln?i(Xi) (1) The above denotes an optimization problem withonly non-negativity constraints.</S>
			<S sid="58" ssid="30">It equates to maximum a posteriori (MAP) inference; hence, the par tition function Z can be ignored.</S>
			<S sid="59" ssid="31">We next discuss the nature of the three different factors in Eq.</S>
			<S sid="60" ssid="32">1.</S>
			<S sid="61" ssid="33">2.2 Log-Factors as Penalties.</S>
			<S sid="62" ssid="34">The nature of the three types of factors in Eq.</S>
			<S sid="63" ssid="35">1governs the behavior of a graph-based SSL algo rithm.</S>
			<S sid="64" ssid="36">Hence, the equation specifies a family of X1 X4 X3 X2 Figure 1: An example factor graph for the graph-based SSL problem.</S>
			<S sid="65" ssid="37">See text for the significance of the shaded and dotted factors, and the shaded variables.</S>
			<S sid="66" ssid="38">graph-based methods that generalize prior research.</S>
			<S sid="67" ssid="39">We desire the following properties to be satisfied in the factors: (i) convexity of Eq.</S>
			<S sid="68" ssid="40">1, (ii) amenability to scalable optimization algorithms, and (iii) sparse solutions as expected in natural language lexicons.</S>
			<S sid="69" ssid="41">Pairwise factors: In our work, for the pairwise factors ?j(Xj , X?j) and ?i?k(Xi, Xk), we examine two functions that penalize inconsistencies between neighboring vertices: the squared `2 norm and the Jensen-Shannon (JS) divergence (Burbea and Rao,1982; Lin, 1991), which is a symmetrized gener alization of the Kullback-Leibler (KL) divergence (Kullback and Leibler, 1951; Cover and Thomas, 1991).</S>
			<S sid="70" ssid="42">These two divergences are symmetric.</S>
			<S sid="71" ssid="43">Both are inspired by previous work; however, the use ofthe JS divergence is a novel extension to Subra manya and Bilmes (2008).</S>
			<S sid="72" ssid="44">Specifically, the factors are: ln?j(Xj , X?j) = ??(qj , rj) (2) ln?i?k(Xi, Xk) = ?2 ? ?</S>
			<S sid="73" ssid="45">wik ? ?(qi, qk) (3)where ? is a hyperparameter whose choice we dis cuss in ?4.</S>
			<S sid="74" ssid="46">The function ?(u, v) for two vectors u and v is defined in two ways: ?(u, v) Gaussian = ?u? v?22 (4) ?(u, v) Entropic = 12 ? y?Y ( u(y) ? ln 2 ? u(y)u(y) + v(y) + v(y) ? ln 2 ? v(y)u(y) + v(y) ) (5) We call the version of ?(u, v) that uses the squared `2 distance (Eq.</S>
			<S sid="75" ssid="47">4) Gaussian, as it represents the idea of label propagation via Gaussian fields proposed by Zhu et al (2003).</S>
			<S sid="76" ssid="48">A minor difference lies in the fact that we include variables Xj , j ? Vl for labeled 679vertices too, and allow them to change, but penal ize them if they go too far away from the observed labeled distributions rj . The other ?(u, v) shown in Eq.</S>
			<S sid="77" ssid="49">5 uses the generalized JS-divergence defined interms of the generalized KL-divergence for unnor malized measures (O?Sullivan, 1998).4Eq.</S>
			<S sid="78" ssid="50">5 improves prior work by replacing the asym metric KL-divergence used to bring the distributionsat labeled vertices close to the corresponding observed distributions, as well as replacing the KL based graph smoothness term with the symmetric JS-divergence (Subramanya and Bilmes, 2008, see first two terms in Eq.</S>
			<S sid="79" ssid="51">1).</S>
			<S sid="80" ssid="52">Empirical evidence showsthat entropic divergences help in multiclass prob lems where a vertex can assume multiple labels, and may perform better than objectives with quadratic penalties (Subramanya and Bilmes, 2008, 2009).</S>
			<S sid="81" ssid="53">A major departure from prior work is the use of unnormalized measures in Eq.</S>
			<S sid="82" ssid="54">4-5, which simplifies optimization even with the complex JS-divergence in the objective function (see ?3), and, we will see, produces comparable and often better results than baselines using normalized distributions (see ?4).</S>
			<S sid="83" ssid="55">Unary factors: The unary factors in our factorgraph ?i(Xi) can incorporate prior information specific to a particular vertex xi embodied by the vari able Xi.</S>
			<S sid="84" ssid="56">Herein, we examine three straightforward penalties, which can be thought of as penalties that encourage either uniformity or sparsity: Uniform squared `2: ln?i(Xi) = ??</S>
			<S sid="85" ssid="57">?qi ? 1|Y | ? ?</S>
			<S sid="86" ssid="58">2 2 (6) Sparse `1: ln?i(Xi) = ??</S>
			<S sid="87" ssid="59">?qi?1 (7) Sparse `1,2: ln?i(Xi) = ??</S>
			<S sid="88" ssid="60">?qi?21 (8)where ? is a hyperparameter whose choice we discuss in ?4.</S>
			<S sid="89" ssid="61">The penalty expressed in Eq.</S>
			<S sid="90" ssid="62">6 penalizes qi if it is far away from the uniform distribu tion.</S>
			<S sid="91" ssid="63">This penalty has been used previously (Das and Petrov, 2011; Das and Smith, 2011; Subramanya et al., 2010), and is similar to the maximum entropy penalty of Subramanya and Bilmes (2008, 2009).The intuition behind its use is that for low confi dence or disconnected regions, one would prefer to have a uniform measure on a graph vertex.</S>
			<S sid="92" ssid="64">Thepenalties in equations 7?8, on the other hand, en courage sparsity in the measure qi; these are related 4The generalized KL divergence is defined asDKL(u?v) = ? y ( u(y) ln u(y)v(y) ? u(y) + v(y) ) . to regularizers for generalized linear models: thelasso (Tibshirani, 1996) and the elitist lasso (Kowal ski and Torre?sani, 2009).</S>
			<S sid="93" ssid="65">The former encourages global sparsity, the latter sparsity per vertex.5 For each vertex, the `1,2 penalty takes the form: ?qi?21 = ? ?</S>
			<S sid="94" ssid="66">y?Y |qi(y)| ? ?</S>
			<S sid="95" ssid="67">2 (9) The `1 norm encourages its argument to be sparse, while the usual observed effect of an `2 norm is a dense vector without many extreme values.</S>
			<S sid="96" ssid="68">The `1,2 penalty is the squared `2 norm of the `1 norms ofevery qi, hence it promotes sparsity within each ver tex, but we observe density over the vertices that are selected.Talukdar (2010) enforced label sparsity for information extraction by discarding poorly scored la bels during graph propagation updates, but did notuse a principled mechanism to arrive at sparse mea sures at graph vertices.</S>
			<S sid="97" ssid="69">Unlike the uniform penalty (Eq.</S>
			<S sid="98" ssid="70">6), sparsity corresponds to the idea of entropy minimization (Grandvalet and Bengio, 2004).</S>
			<S sid="99" ssid="71">Since we use unnormalized measures at each variable Xi, for low confidence graph regions or disconnectedvertices, sparse penalties will result in all zero components in qi, which conveys that the graph prop agation algorithm is not confident on any potential label, a condition that is perfectly acceptable.Model variants: We compare six objective func tions: we combine factor representations from eachof Eqs.</S>
			<S sid="100" ssid="72">4?5 with those from each of Eqs.</S>
			<S sid="101" ssid="73">6?8, replac ing them in the generic graph objective function of Eq.</S>
			<S sid="102" ssid="74">1.</S>
			<S sid="103" ssid="75">The nature of these six models is succinctly summarized in Table 1.</S>
			<S sid="104" ssid="76">For each model, we findthe best set of measures q that maximize the corre sponding graph objective functions, such that q ? 0.</S>
			<S sid="105" ssid="77">Note that in each of the graph objectives, we havetwo hyperparameters ? and ? that control the influence of the second and the third terms of Eq.</S>
			<S sid="106" ssid="78">1 re 5One could additionally consider a non-sparse penalty based on the squared `2 norm with zero mean: ln?i(Xi) = ??</S>
			<S sid="107" ssid="79">?qi?</S>
			<S sid="108" ssid="80">2 2.</S>
			<S sid="109" ssid="81">We experimented with this unary penalty (along with the.</S>
			<S sid="110" ssid="82">pairwise Gaussian penalty for binary factors) for the semantic frame lexicon expansion problem, and found that it performs exactly on par with the squared `2 penalty with uniform mean.</S>
			<S sid="111" ssid="83">To limit the number of non-sparse graph objectives, we omit detailed discussion of experiments with this unary penalty.</S>
			<S sid="112" ssid="84">680 abbrev.</S>
			<S sid="113" ssid="85">factors pairwise unary UGF-`2 Gaussian Uniform squared `2 UGF-`1 Gaussian Sparse `1 UGF-`1,2 Gaussian Sparse `1,2 UJSF-`2 Entropic Uniform squared `2 UJSF-`1 Entropic Sparse `1 UJSF-`1,2 Entropic Sparse `1,2 Table 1: Six variants of graph objective functions novel to this work.</S>
			<S sid="114" ssid="86">These variants combine the pairwise factorrepresentations from Eqs.</S>
			<S sid="115" ssid="87">4?5 with unary factor representations from each of Eqs.</S>
			<S sid="116" ssid="88">6?8 (which either encour age uniform or sparse measures), to be used in the graph objective function expressed in Eq.</S>
			<S sid="117" ssid="89">1.</S>
			<S sid="118" ssid="90">spectively.</S>
			<S sid="119" ssid="91">We discuss how these hyperparameters are chosen in ?4.</S>
			<S sid="120" ssid="92">Baseline Models: We compare the performance of the six graph objectives of Table 1 with two strong baselines that have been used in previouswork.</S>
			<S sid="121" ssid="93">These two models use the following two ob jective functions, and find q s.t. q ? 0 and ?i ? V, ?y?Y qi(y) = 1.</S>
			<S sid="122" ssid="94">The first is a normalized Gaus sian field with a squared uniform `2 penalty as the unary factor (NGF-`2): arg min q, s.t. q?0, ?i?V,?qi?1=1 l?</S>
			<S sid="123" ssid="95">j=1 ?qj ? rj?22 + m?</S>
			<S sid="124" ssid="96">i=1 ? ??</S>
			<S sid="125" ssid="97">k?N (i) wik ?qi ? qk?22 + ? ?</S>
			<S sid="126" ssid="98">?qi ? 1|Y | ? ?</S>
			<S sid="127" ssid="99">2 2 ? ?(10) The second is a normalized KL field with an entropy penalty as the unary factor (NKLF-ME): arg min q, s.t. q?0, ?i?V,?qi?1=1 l?</S>
			<S sid="128" ssid="100">j=1 DKL(rj ? qj)+ m?</S>
			<S sid="129" ssid="101">i=1 ? ??</S>
			<S sid="130" ssid="102">k?N (i) wikDKL(qi ? qk)?</S>
			<S sid="131" ssid="103">?H(qi) ? ?(11)whereH(qi) denotes the Shannon entropy of the dis tribution qi.</S>
			<S sid="132" ssid="104">Both these objectives are constrainedby the fact that every qi must be within the |Y | dimensional probability simplex.</S>
			<S sid="133" ssid="105">The objective function in 10 has been used previously (Das and Smith, 2011; Subramanya et al, 2010) and serves as a generalization of Zhu et al (2003).</S>
			<S sid="134" ssid="106">The entropic objective function in 11, originally called measurepropagation, performed better at multiclass prob lems when compared to graph objectives using the quadratic criterion (Subramanya and Bilmes, 2008).</S>
	</SECTION>
	<SECTION title="Optimization. " number="3">
			<S sid="135" ssid="1">The six variants of Eq.</S>
			<S sid="136" ssid="2">1 in Table 1 are convex in q. This is because the `1, squared `2 and the`1,2 penalties are convex.</S>
			<S sid="137" ssid="3">Moreover, the generalized JS-divergence term, which is a sum of two KL divergence terms, is convex (Cover and Thomas,1991).</S>
			<S sid="138" ssid="4">Since we choose ?, ? and wik to be non negative, these terms?</S>
			<S sid="139" ssid="5">sums are also convex.</S>
			<S sid="140" ssid="6">Thegraph objectives of the two baselines noted in ex pressions 10?11 are also convex because negative entropy in expression 11 is convex, and rest of the penalties are the same as our six objectives.</S>
			<S sid="141" ssid="7">In our work, to optimize the objectives of Table 1, we use a generic quasi-Newton gradient-based optimizer thatcan handle bound-inequality constraints, called L BFGS-B (Zhu et al, 1997).</S>
			<S sid="142" ssid="8">Partial derivatives of the graph objectives are computed with respect to each parameter ?i, y, qi(y) of q and passed on tothe optimizer which updates them such that the ob jective function of Eq.</S>
			<S sid="143" ssid="9">1 is maximized.</S>
			<S sid="144" ssid="10">Note that since the `1 and `1,2 penalties are non-differentiable at 0, special techniques are usually used to compute updates for unconstrained parameters (Andrew and Gao, 2007).</S>
			<S sid="145" ssid="11">However, since q ? 0, their absolutevalue can be assumed to be right-continuous, mak ing the function differentiable.</S>
			<S sid="146" ssid="12">Thus, ? ?qi(y) ?qi?1 = 1 ? ?qi(y) ?qi?21 = 2 ? ?qi?1 (We omit the form of the derivatives of the other penalties for space.)</S>
			<S sid="147" ssid="13">There are several advantages to taking this route towards optimization.</S>
			<S sid="148" ssid="14">The `2 and the JS-divergence penalties for the pairwise termscan be replaced with more interesting convex di vergences if required, and still optimization will bestraightforward.</S>
			<S sid="149" ssid="15">Moreover, the nonnegative con straints make optimization with sparsity inducing penalties easy.</S>
			<S sid="150" ssid="16">Finally, computing the objectivefunction and the partial derivatives is easily paral lelizable on MPI (Gropp et al, 1994) or MapReduce(Dean and Ghemawat, 2008) architectures, by divid ing up the computation across graph vertices.</S>
			<S sid="151" ssid="17">In comparison, constrained problems such as theone in Eq.</S>
			<S sid="152" ssid="18">11 require a specialized alternating mini 681 mization technique (Subramanya and Bilmes, 2008, 2009), that performs two passes through the graph vertices during one iteration of updates, introducesan auxiliary set of probability distributions (thus, increasing memory requirements) and another hyper parameter ? that is used to transform the weightmatrix W to be suitable for the alternating minimization procedure.</S>
			<S sid="153" ssid="19">To optimize the baseline objectives, we borrow the gradient-free iterative up dates described by Subramanya and Bilmes (2009) and Subramanya et al (2010).</S>
	</SECTION>
	<SECTION title="Experiments. " number="4">
			<S sid="154" ssid="1">In this section, we compare the six graph objective functions in Table 1 with the two baseline objectives on two lexicon expansion tasks.</S>
			<S sid="155" ssid="2">4.1 POS Lexicon Expansion.</S>
			<S sid="156" ssid="3">We expand a POS lexicon for word types with a context word on each side, using distributional similar ity in an unlabeled corpus and few labeled trigrams.</S>
			<S sid="157" ssid="4">Data and task: We constructed a graph over wordtrigram types as vertices, using co-occurrence statistics.</S>
			<S sid="158" ssid="5">Following Das and Petrov (2011) and Sub ramanya et al (2010), a similarity score between two trigram types was computed by measuring thecosine similarity between their empirical senten tial context statistics.</S>
			<S sid="159" ssid="6">This similarity score resulted in the symmetric weight matrix W, defining edge weights between pairs of graph vertices.</S>
			<S sid="160" ssid="7">Detailsof the similarity computation are given in those papers.</S>
			<S sid="161" ssid="8">W is thresholded so that only the K near est neighbors for each vertex have similarity greater than zero, giving a sparse graph.</S>
			<S sid="162" ssid="9">We set K = 8 as itresulted in the sparsest graph which was fully con nected.6 For this task, Y is the set of 45 POS tags defined in the Penn Treebank (Marcus et al, 1993), and the measure qi for vertex i (for trigram type xi) corresponds to the set of tags that can be associatedwith the middle word of xi.</S>
			<S sid="163" ssid="10">The trigram representation, as in earlier work, helps reduce the ambi guity of POS tags for the middle word, and helps in graph construction.</S>
			<S sid="164" ssid="11">The 690,705-vertex graph was constructed over all trigram types appearing in6Our proposed methods can deal with graphs containing disconnected components perfectly well.</S>
			<S sid="165" ssid="12">Runtime is asymptoti cally linear in K for all objectives considered here.Sections 00?21 (union of the training and develop ment sets used for POS tagging experiments in prior work) of the WSJ section of the Penn Treebank, but co-occurrence statistics for graph construction were gathered from a million sentences drawn from the English Gigaword corpus (Graff, 2003).</S>
			<S sid="166" ssid="13">Given the graph G with m vertices, we assume that the tag distributions r for l labeled vertices are also provided.</S>
			<S sid="167" ssid="14">Our goal is to find the best set of measures q over the 45 tags for all vertices in the graph.</S>
			<S sid="168" ssid="15">Prior work used a similar lexicon for POSdomain adaptation and POS induction for resource poor languages (Das and Petrov, 2011; Subramanya et al, 2010); such applications of a POS lexicon areout of scope here; we consider only the lexicon ex pansion problem and do an intrinsic evaluation at a type-level to compare the different graph objectives.</S>
			<S sid="169" ssid="16">Experimental details: To evaluate, we randomlychose 6,000 out of the 690,705 types for devel opment.</S>
			<S sid="170" ssid="17">From the remaining types, we randomly chose 588,705 vertices for testing.</S>
			<S sid="171" ssid="18">This left us with96,000 types from which we created sets of differ ent sizes containing 3,000, 6,000, 12,000, 24,000,48,000 and 96,000 labeled types, creating 6 increas ingly easy transduction settings.</S>
			<S sid="172" ssid="19">The developmentand the test types were kept constant for direct per formance comparison across the six settings and oureight models.</S>
			<S sid="173" ssid="20">After running inference, the mea sure qi at vertex i was normalized to 1.</S>
			<S sid="174" ssid="21">Next, for all thresholds ranging from 0 to 1, with steps of 0.001, we measured the average POS tag precision and recall on the development data ? this gave us the area under the precision-recall curve (prAUC),which is often used to measure performance on re trieval tasks.</S>
			<S sid="175" ssid="22">Given a transduction setting and the final q for an objective, hyperparameters ? and ? were tuned on the development set by performing a grid search, targeting prAUC.7 We ran 100 rounds7For the objectives using the uniform `2 and the maxi mum entropy penalties, namely UGF-`2, UJSF-`2, NGF-`2 and NKLF-ME, we chose ? from {0, 10?6, 10?4, 0.1}.</S>
			<S sid="176" ssid="23">For the rest of the models using sparsity inducing penalties, we chose ? from {10?6, 10?4, 0.1}.</S>
			<S sid="177" ssid="24">This suggests that for the formertype of objectives, we allowed a zero unary penalty if that set ting resulted in the best development performance, while for the latter type of models, we enforced a positive unary penalty.</S>
			<S sid="178" ssid="25">In fact, ? = 0 was chosen in several cases for the objectives with uniform penalties indicating that uniformity hurts performance.</S>
			<S sid="179" ssid="26">We chose ? from {0.1, 0.5, 1.0}.</S>
			<S sid="180" ssid="27">682 |Dl|: 3K 6K 12K 24K 48K 96K NGF-`2 0.208 0.219 0.272 0.335 0.430 0.544 NKLF-ME 0.223 0.227 0.276 0.338 0.411 0.506 UGF-`2 0.223 0.257 0.314 0.406 0.483 0.564 UGF-`1 0.223 0.257 0.309 0.406 0.483 0.556 UGF-`1,2 0.223 0.256 0.313 0.403 0.478 0.557 UJSF-`2 0.271 0.250 0.310 0.364 0.409 0.481 UJSF-`1 0.227 0.257 0.317 0.369 0.410 0.481 UJSF-`1,2 0.227 0.258 0.309 0.369 0.409 0.479 Table 2: Area under the precision recall curve for the two baseline objectives and our methods for POS tag lexicon induction.</S>
			<S sid="181" ssid="28">This is a measure of how well the type lexicon (for some types unlabeled during training) is recovered by each method.</S>
			<S sid="182" ssid="29">The test set contains 588,705 types.</S>
			<S sid="183" ssid="30">of iterative updates for all 8 graph objectives.</S>
			<S sid="184" ssid="31">Type-level evaluation: To measure the quality ofthe lexicons, we perform type level evaluation us ing area under the precision-recall curve (prAUC).</S>
			<S sid="185" ssid="32">The same measure (on development data) was used to tune the two hyperparameters.</S>
			<S sid="186" ssid="33">Table 2 shows the results measured on 588,705 test vertices (the same test set was used for all the transduction settings).The general pattern we observe is that our unnor malized approaches almost always perform better than the normalized baselines.</S>
			<S sid="187" ssid="34">(The exception isthe 3,000 labeled example case, where most unnor malized models are on par with the better baseline.)In scenarios with fewer labeled types, pairwise en tropic penalties perform better than Gaussian ones, and the pattern reverses as more labeled types come available.</S>
			<S sid="188" ssid="35">This trend is the same when we compareonly the two baselines.</S>
			<S sid="189" ssid="36">In four out of the six trans duction settings, one of the sparsity-inducing graph objectives achieves the best performance in terms ofprAUC, which is encouraging given that they gener ally produce smaller models than the baselines.</S>
			<S sid="190" ssid="37">Overall, though, using sparsity-inducing unaryfactors seems to have a weak negative effect on performance.</S>
			<S sid="191" ssid="38">Their practical advantage, however is apparent when we consider the size of the model.</S>
			<S sid="192" ssid="39">Af ter the induction of the set of measures q for all transduction settings and all graph objectives, wenoticed that our numerical optimizer (LBFGS-B) of ten assigns extremely small positive values ratherthan zero.</S>
			<S sid="193" ssid="40">This problem can be attributed to sev eral artifacts, including our limit of 100 iterations of optimization.</S>
			<S sid="194" ssid="41">Hence, we use a global threshold of 10?6, and treat any real value below this threshold 0M 5M 11M 16M 21M 27M 32M 3k 6k 12k 24k 48k 96k UGF-?1 UGF-?1,2 UJSF-?2 UJSF-?1 UJSF-?1,2 Figure 2: The number of non-zero components in q forfive graph objective functions proposed in this work, plot ted against various numbers of labeled datapoints.</S>
			<S sid="195" ssid="42">Note that NGF-`2, NKLF-ME and UGF-`2 produce non-zero components for virtually all q, and are therefore not shown (the dotted line marks the maximally non-sparse solution, with 31,081,725 components).</S>
			<S sid="196" ssid="43">All of these five objectives result in sparsity.</S>
			<S sid="197" ssid="44">On average, the objectives employing entropic pairwise penalties with sparse unary penalties UJSF-`1 and UJSF-`1,2 produce very sparse lexicons.</S>
			<S sid="198" ssid="45">Although UGF-`2 produces no sparsity at all, its entropic counterpart UJSF-`2 produces considerablesparsity, which we attribute to JS-divergence as a pair wise penalty.</S>
			<S sid="199" ssid="46">to be zero.</S>
			<S sid="200" ssid="47">Figure 2 shows the number of non-zero components in q (or, the lexicon size) for the graph objectives that achieve sparsity (baselines NGF-`2 and NKLF-ME, plus our UGF-`2 are not expectedto, and do not, achieve sparsity; surprisingly UJSF`2 does and is shown).</S>
			<S sid="201" ssid="48">Even though the hyperpa rameters ? and ? in the graph objective functionswere not tuned towards sparsity, we see that sparsityinducing factors are able to achieve far more com pact lexicons.</S>
			<S sid="202" ssid="49">Sparsity is desirable in settings where labeled development data for tuning thresholds that select the most probable labels for a given type is unavailable (e.g., Das and Petrov, 2011).</S>
			<S sid="203" ssid="50">4.2 Expansion of a Semantic Frame Lexicon.</S>
			<S sid="204" ssid="51">In a second set of experiments, we follow Das and Smith (2011, DS11 henceforth) in expanding a lexicon that associates lexical predicates (targets) with semantic frames (abstract events or scenarios that a predicate evokes when used in a sentential context) as labels.</S>
			<S sid="205" ssid="52">More concretely, each vertex in the graph corresponds to a lemmatized word type with its coarse part of speech, and the labels are frames from the FrameNet lexicon (Fillmore et al, 2003).</S>
			<S sid="206" ssid="53">Graph construction leverages distributional 683 UNKNOWN ALL PREDICATES PREDICATES lexicon exact partial exact partial sizeSupervised 23.08 46.62 82.97 90.51 ?NGF-`2 39.86 62.35 83.51 91.02 128,960 NKLF-ME 36.36 60.07 83.40 90.95 128,960 UGF-`2 37.76 60.81 83.44 90.97 128,960 UGF-`1 39.86 62.85 83.51 91.04 122,799 UGF-`1,2 39.86 62.85 83.51 91.04 128,732 UJSF-`2 40.56 62.81 83.53 91.04 128,232 UJSF-`1 39.16 62.43 83.49 91.02 128,771 UJSF-`1,2 42.67 65.29 83.60 91.12 45,544 Table 3: Exact and partial frame identification accuracywith lexicon size (non-zero frame components).</S>
			<S sid="207" ssid="54">The ?un known predicates?</S>
			<S sid="208" ssid="55">section of the test data contains 144 targets, while the entire test set contains 4,458 targets.Bold indicates best results.</S>
			<S sid="209" ssid="56">The UJSF-`1,2 model pro duces statistically significant results (p  0.001) for all metrics with respect to the supervised baseline used in DS11.</S>
			<S sid="210" ssid="57">For both the unknown targets as well as the whole test set.</S>
			<S sid="211" ssid="58">However, it is weakly significant (p  0.1) compared to the NGF-`2 model for the unseen portion of the test set, when partial frame matching is used.</S>
			<S sid="212" ssid="59">For rest of the settings, the two are statistically indistinguishable.</S>
			<S sid="213" ssid="60">indicates the best results in DS11.</S>
			<S sid="214" ssid="61">similarity as well as linguistic annotations.</S>
			<S sid="215" ssid="62">Data: We borrow the graph-based SSL process ofDS11 in its entirety.</S>
			<S sid="216" ssid="63">The constructed graph contains 64,480 vertices, each corresponding to a tar get, out of which 9,263 were drawn from the labeled data.</S>
			<S sid="217" ssid="64">The possible set of labels Y is the set of 877frames defined in FrameNet; the measure qi corre sponds to the set of frames that a target can evoke.</S>
			<S sid="218" ssid="65">The targets drawn from FrameNet annotated data (l = 9,263) have frame distributions ri with which the graph objectives are seeded.8 Evaluation: The evaluation metric used for this task is frame disambiguation accuracy on a blind test set containing marked targets in free text.</S>
			<S sid="219" ssid="66">A sectionof this test set contained 144 targets, previously un seen in annotated FrameNet data; this section is ofinterest to us and we present separate accuracy results on it.</S>
			<S sid="220" ssid="67">Given the measure qi over frames induced using graph-based SSL for target i, we trun cate it to keep at most the top M frames that get the highest mass under qi, only retaining those with non-zero values.</S>
			<S sid="221" ssid="68">If all components of qi are zero,we remove target i from the lexicon, which is often the case in the sparsity-inducing graph objectives.</S>
			<S sid="222" ssid="69">If a target is unseen in annotated data, a separate probabilistic model (which serves as a supervised baseline like in DS11, row 1 in Table 3) dis ambiguates among the M filtered frames observing the sentential context of the target instance.</S>
			<S sid="223" ssid="70">Thiscan be thought of as combining type- and token level information for inference.</S>
			<S sid="224" ssid="71">If the target waspreviously seen, it is disambiguated using the su 8We refer the reader to DS11 for the details of the graphconstruction method, the FrameNet dataset used, example se mantic frames, and an excerpt of the graph over targets.pervised baseline.</S>
			<S sid="225" ssid="72">The test set and the probabilis tic model are identical to the ones in DS11.</S>
			<S sid="226" ssid="73">We fixed K, the number of nearest neighbors for each vertex, to be 10.</S>
			<S sid="227" ssid="74">For each graph objective, ?, ? and M were chosen by five-fold cross-validation.</S>
			<S sid="228" ssid="75">Thecross-validation sets were the same as the ones de scribed in ?6.3 of DS11.9Results and discussion: Table 3 shows frame iden tification accuracy, both using exact match as wellas partial match that assigns partial credit when a re lated frame is predicted (Baker et al, 2007).</S>
			<S sid="229" ssid="76">The final column presents lexicon size in terms of the set of truncated frame distributions (filtered according to the top M frames in qi) for all the targets in a graph.</S>
			<S sid="230" ssid="77">All the graph-based models are better than the supervised baseline; for our objectives usingpairwise Gaussian fields with sparse unary penal ties, the accuracies are equal or better with respect to NGF-`2; however, the lexicon sizes are reduced by a few hundred to a few thousand entries.</S>
			<S sid="231" ssid="78">Massive reduction in lexicon sizes (as in the POS problem in ?4.1) is not visible for these objectives because we throw out most of the components of the entire set of distributions q and keep only at most the top M(which is automatically chosen to be 2 for all ob jectives) frames per target.</S>
			<S sid="232" ssid="79">Although a significant number of components in the whole distribution qin the sparse objectives get zero mass, the M components for a target tend to be non-zero for a major ity of the targets.</S>
			<S sid="233" ssid="80">Better results are observed for theobjectives using entropic pairwise penalties; the ob 9We chose ? from {0.01, 0.1, 0.3, 0.5, 1.0}; ? was chosen from the same sets as the POS problem.</S>
			<S sid="234" ssid="81">The graph construction hyperparameter ? described by DS11 was fixed to 0.2.</S>
			<S sid="235" ssid="82">As in DS11, M was chosen from {2, 3, 5, 10}.</S>
			<S sid="236" ssid="83">684 (a) t = discrepancy.N t = contribution.N t = print.V t = mislead.V ?SIMILARITY ?GIVING ?TEXT CREATION EXPERIENCER OBJ NATURAL FEATURES MONEY SENDING ?PREVARICATION PREVARICATION COMMITMENT DISPERSAL MANIPULATE INTO DOING QUARRELING ASSISTANCE READING COMPLIANCE DUPLICATION EARNINGS AND LOSSES STATEMENT EVIDENCE t = abused.A t = maker.N t = inspire.V t = failed.A OFFENSES COMMERCE SCENARIO CAUSE TO START SUCCESS OR FAILURE KILLING ?MANUFACTURING EXPERIENCER OBJ ?SUCCESSFUL ACTION COMPLIANCE BUSINESSES ?SUBJECTIVE INFLUENCE UNATTRIBUTED INFORMATION DIFFERENTIATION BEHIND THE SCENES EVOKING PIRACY COMMITTING CRIME SUPPLY ATTEMPT SUASION WANT SUSPECT (b) t = discrepancy.N t = contribution.N t = print.V t = mislead.V ?SIMILARITY ?GIVING ?TEXT CREATION ?PREVARICATION NON-COMMUTATIVE STATEMENT COMMERCE PAY STATE OF ENTITY EXPERIENCER OBJ NATURAL FEATURES COMMITMENT DISPERSAL MANIPULATE INTO DOING ASSISTANCE CONTACTING REASSURING EARNINGS AND LOSSES READING EVIDENCE t = abused.A t = maker.N t = inspire.V t = failed.A ?MANUFACTURING CAUSE TO START ?SUCCESSFUL ACTION BUSINESSES ?SUBJECTIVE INFLUENCE SUCCESSFULLY COMMUNICATE MESSAGE COMMERCE SCENARIO OBJECTIVE INFLUENCE SUPPLY EXPERIENCER OBJ BEING ACTIVE SETTING FIRE Table 4: Top 5 frames (if there are ? 5 frames with mass greater than zero) according to the graph posterior qt(f) for (a) NGF-`2 and (b) UJSF-`1,2, given eight unseen predicates in annotated FrameNet data.</S>
			<S sid="237" ssid="84">marks the correct frame, according to the predicate instances in test data (each of these predicates appear only once in test data).</S>
			<S sid="238" ssid="85">Note that UJSF-`1,2 ranks the correct frame higher than NGF-`2 for several predicates, and produces sparsity quite often; for the predicate abused.A, the correct frame is not listed by NGF-`2, while UJSF-`1,2 removes it altogether from the expanded lexicon, resulting in compactness.</S>
			<S sid="239" ssid="86">jective UJSF-`1,2 gives us the best absolute result by outperforming the baselines by strong margins, and also resulting in a tiny lexicon, less than half the size of the baseline lexicons.</S>
			<S sid="240" ssid="87">The size can be attributed tothe removal of predicates for which all frame com ponents were zero (qi = 0).</S>
			<S sid="241" ssid="88">Table 4 contrasts the induced frames for several unseen predicates for the NGF-`2 and the UJSF-`2 objectives; the latter often ranks the correct frame higher, and produces a small set of frames per predicate.</S>
	</SECTION>
	<SECTION title="Conclusion. " number="5">
			<S sid="242" ssid="1">We have presented a family of graph-based SSL objective functions that incorporate penalties encour aging sparse measures at each graph vertex.</S>
			<S sid="243" ssid="2">Ourmethods relax the oft-used assumption that the measures at each vertex form a normalized probabil ity distribution, making optimization and the use ofcomplex penalties easier than prior work.</S>
			<S sid="244" ssid="3">Optimiza tion is also easy when there are additional terms in a graph objective suited to a specific problem; ourgeneric optimizer would simply require the compu tation of new partial derivatives, unlike prior workthat required specialized techniques for a novel ob jective function.</S>
			<S sid="245" ssid="4">Finally, experiments on two natural language lexicon learning problems show that our methods produce better performance with respect to state-of-the-art graph-based SSL methods, and also result in much smaller lexicons.</S>
			<S sid="246" ssid="5">Acknowledgments We thank Andre?</S>
			<S sid="247" ssid="6">Martins, Amar Subramanya, and Partha Talukdar for helpful discussion during the progress of thiswork and the three anonymous reviewers for their valuable feedback.</S>
			<S sid="248" ssid="7">This research was supported by Qatar Na tional Research Foundation grant NPRP 08-485-1-083, Google?s support of the Worldly Knowledge Project, andTeraGrid resources provided by the Pittsburgh Supercom puting Center under NSF grant number TG-DBS110003.</S>
			<S sid="249" ssid="8">685</S>
	</SECTION>
</PAPER>
