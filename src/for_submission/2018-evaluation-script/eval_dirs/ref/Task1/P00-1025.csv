Citance Number,Reference Article,Citing Article,Citation Marker Offset,Citation Marker,Citation Offset,Citation Text,Citation Text Clean,Reference Offset,Reference Text,Discourse Facet
2,P00-1025,P55-62,'52',7.0,'52',dummy,dummy,['123'],"<S ssid=""1"" sid=""55"">modeled in finite state terms as concatenation.</S><S ssid=""1"" sid=""0"">Finite-State Non-Concatenative Morphotactics</S><S ssid=""1"" sid=""1"">Finite-state morphology in the general tradition of the Two-Level and Xerox implementations has proved very successful in the production of robust morphological analyzer-generators, including many large-scale commercial systems.</S><S ssid=""1"" sid=""198"">4.2 Arabic Morphological.</S>",methodcitation
3,P00-1025,P9852-P00,"'200','201'","Beesley and Karttunen,2000","'200', '201'",dummy,dummy,['203'],"<S ssid=""1"" sid=""191"">4.1 Malay Morphological.</S><S ssid=""1"" sid=""83"">3.1 Reduplication.</S>",methodcitation
5,P00-1025,PE2006-P00,'104',"Beesley and Karttunen,2000",'104',dummy,dummy,['62'],"<S ssid=""1"" sid=""3"">We describe a new technique for constructing finite- state transducers that involves reapplying the regular-expression compiler to its own output.</S><S ssid=""1"" sid=""108"">The technique implemented in compile-replace is a general way of allowing the regular-expression compiler to reapply to and modify its own output.</S><S ssid=""1"" sid=""62"">The compile- replace algorithm then reapplies the regular- expression compiler to its own output, compiling the regular-expression substrings in the intermediate network and replacing them with the result of the compilation.</S><S ssid=""1"" sid=""202"">The technique described here, implemented in the compile-replace algorithm, allows the regular-expression compiler to reapply to and modify its own output, effectively freeing morphotactic description to use any finite-state operation.</S><S ssid=""1"" sid=""15"">Regular-expression descriptions are compiled into finite-state automata or transducers (collectively called networks) as usual, and then the compiler is reapplied to its own output, producing a modified but still finite- state network.</S>",methodcitation
6,P00-1025,PLEX-P00,'31',"Beesley and Karttunen,2000",'31',dummy,dummy,['119'],"<S ssid=""1"" sid=""2"">However, it has long been recognized that these implementations have serious limitations in handling non-concatenative phenomena.</S><S ssid=""1"" sid=""4"">Implemented in an algorithm called compile- replace, this technique has proved useful for handling non-concatenative phenomena; and we demonstrate it on Malay full-stem reduplication and Arabic stem interdigitation.</S>",methodcitation
7,P00-1025,PLEX-P00,'32',"Beesley and Karttunen,2000",'32',dummy,dummy,['16'],"<S ssid=""1"" sid=""90"">Productive reduplication cannot be described by finite-state or even context-free formalisms.</S><S ssid=""1"" sid=""83"">3.1 Reduplication.</S>",methodcitation
8,P00-1025,PMORPH-P00,'67',Beesley and Karttunen,'67',dummy,dummy,['96'],"<S ssid=""1"" sid=""96"">In the regular expression calculus there are several operators that involve concatenation.</S>",methodcitation
10,P00-1025,PSTAT-P00,'86',"Beesley and Karttunen,2000",'86',dummy,dummy,['131'],"<S ssid=""1"" sid=""75"">Figure 8: A Network with a Regular-Expression Substring on the Lower Side The application of the compile-replace algorithm to the lower side of the network eliminates the markers, compiles the regular expression a* and maps the upper side of the path to the language resulting from the compilation.</S><S ssid=""1"" sid=""151"">We use the networks in Figure 13 to illustrate the effect of the merge algorithm.</S>",methodcitation
11,P00-1025,W02-0503,'17',"Beesley and Karttunen,2000",'17',dummy,dummy,['202'],"<S ssid=""1"" sid=""3"">We describe a new technique for constructing finite- state transducers that involves reapplying the regular-expression compiler to its own output.</S><S ssid=""1"" sid=""202"">The technique described here, implemented in the compile-replace algorithm, allows the regular-expression compiler to reapply to and modify its own output, effectively freeing morphotactic description to use any finite-state operation.</S><S ssid=""1"" sid=""15"">Regular-expression descriptions are compiled into finite-state automata or transducers (collectively called networks) as usual, and then the compiler is reapplied to its own output, producing a modified but still finite- state network.</S><S ssid=""1"" sid=""108"">The technique implemented in compile-replace is a general way of allowing the regular-expression compiler to reapply to and modify its own output.</S><S ssid=""1"" sid=""29"">If the relation is finite-state, then it can be defined using the metalanguage of regular expressions; and, with a suitable compiler, the regular expression source code can be compiled into a finite-state transducer (fst), as shown in Figure 4, that implements the relation computationally.</S>",methodcitation
12,P00-1025,W07-0802,'134',"Beesley and Karttunen,2000",'134',dummy,dummy,['123'],"<S ssid=""1"" sid=""1"">Finite-state morphology in the general tradition of the Two-Level and Xerox implementations has proved very successful in the production of robust morphological analyzer-generators, including many large-scale commercial systems.</S>",methodcitation
13,P00-1025,W08-0703,'15',"Beesley and Karttunen,2000",'15',dummy,dummy,['50'],"<S ssid=""1"" sid=""55"">modeled in finite state terms as concatenation.</S><S ssid=""1"" sid=""0"">Finite-State Non-Concatenative Morphotactics</S>",methodcitation
14,P00-1025,W09-0802,'207',"Beesley and Karttunen,2000",'207',dummy,dummy,['205'],"<S ssid=""1"" sid=""60"">We will proceed with descriptions of how Malay reduplication and Semitic stem interdigitation are handled in finite-state morphology using the new compile-replace algorithm.</S><S ssid=""1"" sid=""213"">But this task can be accomplished, in fact quite efficiently, by using the compile-replace technique.</S><S ssid=""1"" sid=""205"">The compile-replace algorithm and the merge operator introduced in this paper are general techniques not limited to handling the specific</S><S ssid=""1"" sid=""95"">To understand the general solution to full- stem reduplication using the compile-replace algorithm requires a bit of background.</S><S ssid=""1"" sid=""4"">Implemented in an algorithm called compile- replace, this technique has proved useful for handling non-concatenative phenomena; and we demonstrate it on Malay full-stem reduplication and Arabic stem interdigitation.</S>",methodcitation
