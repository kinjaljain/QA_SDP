<PAPER>
  <S sid="0">Constraints On Non-Projective Dependency Parsing</S>
  <ABSTRACT>
    <S sid="1" ssid="1">We investigate a series of graph-theoretic constraints on non-projective dependency and their effect on i.e. whether they allow naturally occurring syntactic constructions to be adequately and i.e. whether they reduce the search space for the parser.</S>
    <S sid="2" ssid="2">In particular, we define a new measure the non-projectivity in an acyclic dependency graph obeying the single-head constraint.</S>
    <S sid="3" ssid="3">The constraints are evaluated experimentally using data from the Prague Dependency Treebank and the Danish Dependency Treebank.</S>
    <S sid="4" ssid="4">The results indicate that, whereas complete linguistic coverage in principle requires unrestricted non-projective dependency graphs, limiting the degree of non-projectivity to at most 2 can reduce average running time from quadratic to linear, while excluding less than 0.5% of the dependency graphs found in the two treebanks.</S>
    <S sid="5" ssid="5">This is a substantial improvement over the commonly used projective approximation (degree 0), which excludes 15&#8211;25% of the graphs.</S>
  </ABSTRACT>
  <SECTION title="1 Introduction" number="1">
    <S sid="6" ssid="1">Data-driven approaches to syntactic parsing has until quite recently been limited to representations that do not capture non-local dependencies.</S>
    <S sid="7" ssid="2">This is true regardless of whether representations are based on constituency, where such dependencies are traditionally represented by empty categories and coindexation to avoid explicitly discontinuous constituents, or on dependency, where it is more common to use a direct encoding of so-called nonprojective dependencies.</S>
    <S sid="8" ssid="3">While this &#8220;surface dependency approximation&#8221; (Levy and Manning, 2004) may be acceptable for certain applications of syntactic parsing, it is clearly not adequate as a basis for deep semantic interpretation, which explains the growing body of research devoted to different methods for correcting this approximation.</S>
    <S sid="9" ssid="4">Most of this work has so far focused either on post-processing to recover non-local dependencies from context-free parse trees (Johnson, 2002; Jijkoun and De Rijke, 2004; Levy and Manning, 2004; Campbell, 2004), or on incorporating nonlocal dependency information in nonterminal categories in constituency representations (Dienes and Dubey, 2003; Hockenmaier, 2003; Cahill et al., 2004) or in the categories used to label arcs in dependency representations (Nivre and Nilsson, 2005).</S>
    <S sid="10" ssid="5">By contrast, there is very little work on parsing methods that allow discontinuous constructions to be represented directly in the syntactic structure, whether by discontinuous constituent structures or by non-projective dependency structures.</S>
    <S sid="11" ssid="6">Notable exceptions are Plaehn (2000), where discontinuous phrase structure grammar parsing is explored, and McDonald et al. (2005b), where nonprojective dependency structures are derived using spanning tree algorithms from graph theory.</S>
    <S sid="12" ssid="7">One question that arises if we want to pursue the structure-based approach is how to constrain the class of permissible structures.</S>
    <S sid="13" ssid="8">On the one hand, we want to capture all the constructions that are found in natural languages, or at least to provide a much better approximation than before.</S>
    <S sid="14" ssid="9">On the other hand, it must still be possible for the parser not only to search the space of permissible structures in an efficient way but also to learn to select the most appropriate structure for a given sentence with sufficient accuracy.</S>
    <S sid="15" ssid="10">This is the usual tradeoff between expressivity and complexity, where a less restricted class of permissible structures can capture more complex constructions, but where the enlarged search space makes parsing harder with respect to both accuracy and efficiency.</S>
    <S sid="16" ssid="11">Whereas extensions to context-free grammar have been studied quite extensively, there are very few corresponding results for dependency-based systems.</S>
    <S sid="17" ssid="12">Since Gaifman (1965) proved that his projective dependency grammar is weakly equivalent to context-free grammar, Neuhaus and Br&#168;oker (1997) have shown that the recognition problem for a dependency grammar that can define arbitrary non-projective structures is NP complete, but there are no results for systems of intermediate complexity.</S>
    <S sid="18" ssid="13">The pseudo-projective grammar proposed by Kahane et al. (1998) can be parsed in polynomial time and captures non-local dependencies through a form of gap-threading, but the structures generated by the grammar are strictly projective.</S>
    <S sid="19" ssid="14">Moreover, the study of formal grammars is only partially relevant for research on datadriven dependency parsing, where most systems are not grammar-based but rely on inductive inference from treebank data (Yamada and Matsumoto, 2003; Nivre et al., 2004; McDonald et al., 2005a).</S>
    <S sid="20" ssid="15">For example, despite the results of Neuhaus and Br&#168;oker (1997), McDonald et al. (2005b) perform parsing with arbitrary non-projective dependency structures in O(n2) time.</S>
    <S sid="21" ssid="16">In this paper, we will therefore approach the problem from a slightly different angle.</S>
    <S sid="22" ssid="17">Instead of investigating formal dependency grammars and their complexity, we will impose a series of graphtheoretic constraints on dependency structures and see how these constraints affect expressivity and parsing efficiency.</S>
    <S sid="23" ssid="18">The approach is mainly experimental and we evaluate constraints using data from two dependency-based treebanks, the Prague Dependency Treebank (Haji&#711;c et al., 2001) and the Danish Dependency Treebank (Kromann, 2003).</S>
    <S sid="24" ssid="19">Expressivity is investigated by examining how large a proportion of the structures found in the treebanks are parsable under different constraints, and efficiency is addressed by considering the number of potential dependency arcs that need to be processed when parsing these structures.</S>
    <S sid="25" ssid="20">This is a relevant metric for data-driven approaches, where parsing time is often dominated by the computation of model predictions or scores for such arcs.</S>
    <S sid="26" ssid="21">The parsing experiments are performed with a variant of Covington&#8217;s algorithm for dependency parsing (Covington, 2001), using the treebank as an oracle in order to establish an upper bound on accuracy.</S>
    <S sid="27" ssid="22">However, the results are relevant for a larger class of algorithms that derive nonprojective dependency graphs by treating every possible word pair as a potential dependency arc.</S>
    <S sid="28" ssid="23">The paper is structured as follows.</S>
    <S sid="29" ssid="24">In section 2 we define dependency graphs, and in section 3 we formulate a number of constraints that can be used to define different classes of dependency graphs, ranging from unrestricted non-projective to strictly projective.</S>
    <S sid="30" ssid="25">In section 4 we introduce the parsing algorithm used in the experiments, and in section 5 we describe the experimental setup.</S>
    <S sid="31" ssid="26">In section 6 we present the results of the experiments and discuss their implications for non-projective dependency parsing.</S>
    <S sid="32" ssid="27">We conclude in section 7.</S>
  </SECTION>
  <SECTION title="2 Dependency Graphs" number="2">
    <S sid="33" ssid="1">A dependency graph is a labeled directed graph, the nodes of which are indices corresponding to the tokens of a sentence.</S>
    <S sid="34" ssid="2">Formally: Definition 1 Given a set R of dependency types (arc labels), a dependency graph for a sentence The set of V of nodes (or vertices) is the set Zn+1 = 10, 1, 2, ... , n} (n E Z+), i.e., the set of non-negative integers up to and including n. This means that every token index i of the sentence is a node (1 &lt; i &lt; n) and that there is a special node 0, which does not correspond to any token of the sentence and which will always be a root of the dependency graph (normally the only root).</S>
    <S sid="35" ssid="3">The set E of arcs (or edges) is a set of ordered pairs (i, j), where i and j are nodes.</S>
    <S sid="36" ssid="4">Since arcs are used to represent dependency relations, we will say that i is the head and j is the dependent of the arc (i, j).</S>
    <S sid="37" ssid="5">As usual, we will use the notation i &#8594; j to mean that there is an arc connecting i and j (i.e., (i, j) &#8712; E) and we will use the notation i &#8594;&#8727; j for the reflexive and transitive closure of the arc relation E (i.e., i &#8594;&#8727; j if and only if The function L assigns a dependency type (arc label) r &#8712; R to every arc e &#8712; E. Figure 1 shows a Czech sentence from the Prague Dependency Treebank with a well-formed dependency graph according to Definition 1&#8211;2.</S>
  </SECTION>
  <SECTION title="3 Constraints" number="3">
    <S sid="38" ssid="1">The only conditions so far imposed on dependency graphs is that the special node 0 be a root and that the graph be connected.</S>
    <S sid="39" ssid="2">Here are three further constraints that are common in the literature: i &#8594;&#8727; k, for every node k such that i &lt; k &lt; j or j &lt; k &lt; i (PROJECTIVITY).</S>
    <S sid="40" ssid="3">Note that these conditions are independent in that none of them is entailed by any (combination) of the others.</S>
    <S sid="41" ssid="4">However, the conditions SINGLEHEAD and ACYCLICITY together with the basic well-formedness conditions entail that the graph is a tree rooted at the node 0.</S>
    <S sid="42" ssid="5">These constraints are assumed in almost all versions of dependency grammar, especially in computational systems.</S>
    <S sid="43" ssid="6">By contrast, the PROJECTIVITY constraint is much more controversial.</S>
    <S sid="44" ssid="7">Broadly speaking, we can say that whereas most practical systems for dependency parsing do assume projectivity, most dependency-based linguistic theories do not.</S>
    <S sid="45" ssid="8">More precisely, most theoretical formulations of dependency grammar regard projectivity as the norm but also recognize the need for non-projective representations to capture non-local dependencies (Mel&#8217;&#711;cuk, 1988; Hudson, 1990).</S>
    <S sid="46" ssid="9">In order to distinguish classes of dependency graphs that fall in between arbitrary non-projective and projective, we define a notion of degree of non-projectivity, such that projective graphs have degree 0 while arbitrary non-projective graphs have unbounded degree.</S>
    <S sid="47" ssid="10">Definition 3 Let G = (V, E, L) be a well-formed dependency graph, satisfying SINGLE-HEAD and ACYCLICITY, and let Ge be the subgraph of G that only contains nodes between i and j for the arc e = (i, j) (i.e., Ve = {i+1, ... , j&#8722;1} if i &lt; j and Ve = {j+1,...,i&#8722;1} if i &gt; j).</S>
    <S sid="48" ssid="11">To exemplify the notion of degree, we note that the dependency graph in Figure 1 (which satisfies SINGLE-HEAD and ACYCLICITY) has degree 1.</S>
    <S sid="49" ssid="12">The only non-projective arc in the graph is (5, 1) and G(5,1) contains three connected components, each of which consists of a single root node (2, 3 and 4).</S>
    <S sid="50" ssid="13">Since only one of these, 3, is not dominated by 5, the arc (5, 1) has degree 1.</S>
  </SECTION>
  <SECTION title="4 Parsing Algorithm" number="4">
    <S sid="51" ssid="1">Covington (2001) describes a parsing strategy for dependency representations that has been known since the 1960s but not presented in the literature.</S>
    <S sid="52" ssid="2">The left-to-right (or incremental) version of this strategy can be formulated in the following way: The operation LINK(i, j) nondeterministically chooses between (i) adding the arc i &#8212;* j (with some label), (ii) adding the arc j &#8212;* i (with some label), and (iii) adding no arc at all.</S>
    <S sid="53" ssid="3">In this way, the algorithm builds a graph by systematically trying to link every pair of nodes (i, j) (i &gt; j).</S>
    <S sid="54" ssid="4">This graph will be a well-formed dependency graph, provided that we also add arcs from the root node 0 to every root node in 11,... , n}.</S>
    <S sid="55" ssid="5">Assuming that the LINK(i, j) operation can be performed in some constant time c, the running time of the algorithm is Eni=1 c(n &#8722; 1) = c(n22 &#8722; n2 ), which in terms of asymptotic complexity is O(n2).</S>
    <S sid="56" ssid="6">In the experiments reported in the following sections, we modify this algorithm by making the performance of LINK(i, j) conditional on the arcs (i, j) and (j, i) being permissible under the given graph constraints: The function PERMISSIBLE(i, j, C) returns true iff i &#8212;* j and j &#8212;* i are permissible arcs relative to the constraint C and the partially built graph G. For example, with the constraint SINGLEHEAD, LINK(i, j) will not be performed if both i and j already have a head in the dependency graph.</S>
    <S sid="57" ssid="7">We call the pairs (i, j) (i &gt; j) for which LINK(i, j) is performed (for a given sentence and set of constraints) the active pairs, and we use the number of active pairs, as a function of sentence length, as an abstract measure of running time.</S>
    <S sid="58" ssid="8">This is well motivated if the time required to compute PERMISSIBLE(i, j, C) is insignificant compared to the time needed for LINK(i, j), as is typically the case in data-driven systems, where LINK(i, j) requires a call to a trained classifier, while PERMISSIBLE(i, j, C) only needs access to the partially built graph G. The results obtained in this way will be partially dependent on the particular algorithm used, but they can in principle be generalized to any algorithm that tries to link all possible word pairs and that satisfies the following condition: For any graph G = (V, E, L) derived by the algorithm, if e, e' E E and e covers e', then the algorithm adds e' before e. This condition is satisfied not only by Covington&#8217;s incremental algorithm but also by algorithms that add arcs strictly in order of increasing length, such as the algorithm of Eisner (2000) and other algorithms based on dynamic programming.</S>
  </SECTION>
  <SECTION title="5 Experimental Setup" number="5">
    <S sid="59" ssid="1">The experiments are based on data from two treebanks.</S>
    <S sid="60" ssid="2">The Prague Dependency Treebank (PDT) contains 1.5M words of newspaper text, annotated in three layers (Haji&#711;c, 1998; Haji&#711;c et al., 2001) according to the theoretical framework of Functional Generative Description (Sgall et al., 1986).</S>
    <S sid="61" ssid="3">Our experiments concern only the analytical layer and are based on the dedicated training section of the treebank.</S>
    <S sid="62" ssid="4">The Danish Dependency Treebank (DDT) comprises 100K words of text selected from the Danish PAROLE corpus, with annotation of primary and secondary dependencies based on Discontinuous Grammar (Kromann, 2003).</S>
    <S sid="63" ssid="5">Only primary dependencies are considered in the experiments, which are based on 80% of the data (again the standard training section).</S>
    <S sid="64" ssid="6">The experiments are performed by parsing each sentence of the treebanks while using the gold standard dependency graph for that sentence as an oracle to resolve the nondeterministic choice in the LINK(i, j) operation as follows: where Eg is the arc relation of the gold standard dependency graph Gg and E is the arc relation of the graph G built by the parsing algorithm.</S>
    <S sid="65" ssid="7">Conditions are varied by cumulatively adding constraints in the following order: The purpose of the experiments is to study how different constraints influence expressivity and running time.</S>
    <S sid="66" ssid="8">The first dimension is investigated by comparing the dependency graphs produced by the parser with the gold standard dependency graphs in the treebank.</S>
    <S sid="67" ssid="9">This gives an indication of the extent to which naturally occurring structures can be parsed correctly under different constraints.</S>
    <S sid="68" ssid="10">The results are reported both as the proportion of individual dependency arcs (per token) and as the proportion of complete dependency graphs (per sentence) recovered correctly by the parser.</S>
    <S sid="69" ssid="11">In order to study the effects on running time, we examine how the number of active pairs varies as a function of sentence length.</S>
    <S sid="70" ssid="12">Whereas the asymptotic worst-case complexity remains O(n2) under all conditions, the average running time will decrease with the number of active pairs if the LINK(i, j) operation is more expensive than the call to PERMISSIBLE(i, j, C).</S>
    <S sid="71" ssid="13">For data-driven dependency parsing, this is relevant not only for parsing efficiency, but also because it may improve training efficiency by reducing the number of pairs that need to be included in the training data.</S>
  </SECTION>
  <SECTION title="6 Results and Discussion" number="6">
    <S sid="72" ssid="1">Table 1 displays the proportion of dependencies (single arcs) and sentences (complete graphs) in the two treebanks that can be parsed exactly with Covington&#8217;s algorithm under different constraints.</S>
    <S sid="73" ssid="2">Starting at the bottom of the table, we see that the unrestricted algorithm (None) of course reproduces all the graphs exactly, but we also see that the constraints SINGLE-HEAD and ACYCLICITY do not put any real restrictions on expressivity with regard to the data at hand.</S>
    <S sid="74" ssid="3">However, this is primarily a reflection of the design of the treebank annotation schemes, which in themselves require dependency graphs to obey these constraints.2 If we go to the other end of the table, we see that PROJECTIVITY, on the other hand, has a very noticeable effect on the parser&#8217;s ability to capture the structures found in the treebanks.</S>
    <S sid="75" ssid="4">Almost 25% of the sentences in PDT, and more than 15% in DDT, are beyond its reach.</S>
    <S sid="76" ssid="5">At the level of individual dependencies, the effect is less conspicuous, but it is still the case in PDT that one dependency in twenty-five cannot be found by the parser even with a perfect oracle (one in fifty in DDT).</S>
    <S sid="77" ssid="6">It should be noted that the proportion of lost dependencies is about twice as high as the proportion of dependencies that are non-projective in themselves (Nivre and Nilsson, 2005).</S>
    <S sid="78" ssid="7">This is due to error propagation, since some projective arcs are blocked from the parser&#8217;s view because of missing non-projective arcs.</S>
    <S sid="79" ssid="8">Considering different bounds on the degree of non-projectivity, finally, we see that even the tightest possible bound (d &lt; 1) gives a much better approximation than PROJECTIVITY, reducing the 2It should be remembered that we are only concerned with one layer of each annotation scheme, the analytical layer in PDT and the primary dependencies in DDT.</S>
    <S sid="80" ssid="9">Taking several layers into account simultaneously would have resulted in more complex structures. proportion of non-parsable sentences with about 90% in both treebanks.</S>
    <S sid="81" ssid="10">At the level of individual arcs, the reduction is even greater, about 95% for both data sets.</S>
    <S sid="82" ssid="11">And if we allow a maximum degree of 2, we can capture more than 99.9% of all dependencies, and more than 99.5% of all sentences, in both PDT and DDT.</S>
    <S sid="83" ssid="12">At the same time, there seems to be no principled upper bound on the degree of non-projectivity, since in PDT not even an upper bound of 10 is sufficient to correctly capture all dependency graphs in the treebank.3 Let us now see how different constraints affect running time, as measured by the number of active pairs in relation to sentence length.</S>
    <S sid="84" ssid="13">A plot of this relationship for a subset of the conditions can be found in Figure 2.</S>
    <S sid="85" ssid="14">For reasons of space, we only display the data from DDT, but the PDT data exhibit very similar patterns.</S>
    <S sid="86" ssid="15">Both treebanks are represented in Table 2, where we show the result of fitting the quadratic equation y = ax + bx2 to the data from each condition (where y is the number of active words and x is the number of words in the sentence).</S>
    <S sid="87" ssid="16">The amount of variance explained is given by the r2 value, which shows a very good fit under all conditions, with statistical significance beyond the 0.001 level.4 Both Figure 2 and Table 2 show very clearly that, with no constraints, the relationship between words and active pairs is exactly the one predicted by the worst case complexity (cf. section 4) and that, with each added constraint, this relationship becomes more and more linear in shape.</S>
    <S sid="88" ssid="17">When we get to PROJECTIVITY, the quadratic coefficient b is so small that the average running time is practically linear for the great majority of sentences.</S>
    <S sid="89" ssid="18">However, the complexity is not much worse for the bounded degrees of non-projectivity (d &lt; 1, d &lt; 2).</S>
    <S sid="90" ssid="19">More precisely, for both data sets, the linear term ax dominates the quadratic term bx2 for sentences up to 50 words at d &lt; 1 and up to 30 words at d &lt; 2.</S>
    <S sid="91" ssid="20">Given that sentences of 50 words or less represent 98.9% of all sentences in PDT and 98.3% in DDT (the corresponding percentages for 30 words being 88.9% and 86.0%), it seems that the average case running time can be regarded as linear also for these models.</S>
  </SECTION>
  <SECTION title="7 Conclusion" number="7">
    <S sid="92" ssid="1">We have investigated a series of graph-theoretic constraints on dependency structures, aiming to find a better approximation than PROJECTIVITY for the structures found in naturally occurring data, while maintaining good parsing efficiency.</S>
    <S sid="93" ssid="2">In particular, we have defined the degree of nonprojectivity in terms of the maximum number of connected components that occur under a dependency arc without being dominated by the head of that arc.</S>
    <S sid="94" ssid="3">Empirical experiments based on data from two treebanks, from different languages and with different annotation schemes, have shown that limiting the degree d of non-projectivity to 1 or 2 gives an average case running time that is linear in practice and allows us to capture about 98% of the dependency graphs actually found in the treebanks with d &lt; 1, and about 99.5% with d &lt; 2.</S>
    <S sid="95" ssid="4">This is a substantial improvement over the projective approximation, which only allows 75&#8211;85% of the dependency graphs to be captured exactly.</S>
    <S sid="96" ssid="5">This suggests that the integration of such constraints into non-projective parsing algorithms will improve both accuracy and efficiency, but we have to leave the corroboration of this hypothesis as a topic for future research.</S>
  </SECTION>
  <SECTION title="Acknowledgments" number="8">
    <S sid="97" ssid="1">The research reported in this paper was partially funded by the Swedish Research Council (6212002-4207).</S>
    <S sid="98" ssid="2">The insightful comments of three anonymous reviewers helped improve the final version of the paper.</S>
  </SECTION>
</PAPER>
