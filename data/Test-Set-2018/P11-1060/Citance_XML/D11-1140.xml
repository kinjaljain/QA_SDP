<PAPER>
  <S sid="0">Lexical Generalization in CCG Grammar Induction for Semantic Parsing</S>
  <ABSTRACT>
    <S sid="1" ssid="1">We consider the problem of learning factored probabilistic CCG grammars for semantic parsing from data containing sentences paired with logical-form meaning representations.</S>
    <S sid="2" ssid="2">Traditional CCG lexicons list lexical items that pair words and phrases with syntactic and semantic content.</S>
    <S sid="3" ssid="3">Such lexicons can be inefficient when words appear repeatedly with closely related lexical content.</S>
    <S sid="4" ssid="4">In this paper, we introduce factored lexicons, which both model word meaning model systematic variation in word usage.</S>
    <S sid="5" ssid="5">We also present an algorithm for learning factored CCG lexicons, along with a probabilistic parse-selection model.</S>
    <S sid="6" ssid="6">Evaluations on benchmark datasets demonstrate that the approach learns highly accurate parsers, whose generalization performance benefits greatly from the lexical factoring.</S>
  </ABSTRACT>
  <SECTION title="1 Introduction" number="1">
    <S sid="7" ssid="1">Semantic parsers automatically recover representations of meaning from natural language sentences.</S>
    <S sid="8" ssid="2">Recent work has focused on learning such parsers directly from corpora made up of sentences paired with logical meaning representations (Kate et al., 2005; Kate and Mooney, 2006; Wong and Mooney, 2006, 2007; Zettlemoyer and Collins, 2005, 2007; Lu et al., 2008; Kwiatkowski et al., 2010).</S>
    <S sid="9" ssid="3">For example, in a flight booking domain we might have access to training examples such as: and the goal is to learn a grammar that can map new, unseen, sentences onto their corresponding meanings, or logical forms.</S>
    <S sid="10" ssid="4">One approach to this problem has developed algorithms for leaning probabilistic CCG grammars (Zettlemoyer and Collins, 2005, 2007; Kwiatkowski et al., 2010).</S>
    <S sid="11" ssid="5">These grammars are well-suited to the task of semantic parsing, as they closely link syntax and semantics.</S>
    <S sid="12" ssid="6">They can be used to model a wide range of complex linguistic phenomena and are strongly lexicalized, storing all language-specific grammatical information directly with the words in the lexicon.</S>
    <S sid="13" ssid="7">For example, a typical learned lexicon might include entries such as: Although lexicalization of this kind is useful for learning, as we will see, these grammars can also suffer from sparsity in the training data, since closely related entries must be repeatedly learned for all members of a certain class of words.</S>
    <S sid="14" ssid="8">For example, the list above shows a selection of lexical items that would have to be learned separately.</S>
    <S sid="15" ssid="9">In this list, the word &#8220;flight&#8221; is paired with the predicate flight in three separate lexical items which are required for different syntactic contexts.</S>
    <S sid="16" ssid="10">Item (1) has the standard N category for entries of this are required to construct the final meaning representype, item (2) allows the use of the word &#8220;flight&#8221; tations are not explicitly labeled in the training data. with that-less relative clauses such as &#8220;flight depart- Instead, we model them with hidden variables and ing Boston&#8221;, and item (3) is useful for phrases with develop an online learning approach that simultaneunconventional word order such as &#8220;from Boston ously estimates the parameters of a log-linear parsflight to New York&#8221;.</S>
    <S sid="17" ssid="11">Representing these three lexi- ing model, while inducing the factored lexicon. cal items separately is inefficient, since each word of We evaluate the approach on the benchmark Atis this class (such as &#8220;fare&#8221;) will require three similarly and GeoQuery domains.</S>
    <S sid="18" ssid="12">This is a challenging setup, structured lexical entries differing only in predicate since the GeoQuery data has complex meaning repname.</S>
    <S sid="19" ssid="13">There may also be systemtatic semantic vari- resentations and sentences in multiple languages, ation between entries for a certain class of words. while the Atis data contains spontaneous, unedited For example, in (6) &#8220;Boston&#8221; is paired with the con- text that can be difficult to analyze with a formal stant bos that represents its meaning.</S>
    <S sid="20" ssid="14">However, item grammar representation.</S>
    <S sid="21" ssid="15">Our approach achieves at (7) also adds the predicate from to the logical form. or near state-of-the-art recall across all conditions, This might be used to analyse somewhat elliptical, despite having no English or domain-specific inforunedited sentences such as &#8220;Show me flights Boston mation built in.</S>
    <S sid="22" ssid="16">We believe that ours is the only systo New York,&#8221; which can be challenging for seman- tem of sufficient generality to run with this degree of tic parsers (Zettlemoyer and Collins, 2007). success on all of these datasets.</S>
    <S sid="23" ssid="17">This paper builds upon the insight that a large pro- 2 Related work portion of the variation between lexical items for There has been significant previous work on learna given class of words is systematic.</S>
    <S sid="24" ssid="18">Therefore it ing semantic parsers from training sentences lashould be represented once and applied to a small set belled with logical form meaning representations. of basic lexical units.</S>
    <S sid="25" ssid="19">1 We develop a factored lex- We extend a line of research that has addressed icon that captures this insight by distinguishing lex- this problem by developing CCG grammar inducemes, which pair words with logical constants, from tion techniques.</S>
    <S sid="26" ssid="20">Zettlemoyer and Collins (2005, lexical templates, which map lexemes to full lexical 2007) presented approaches that use hand generitems.</S>
    <S sid="27" ssid="21">As we will see, this can lead to a significantly ated, English-language specific rules to generate lexmore compact lexicon that can be learned from less ical items from logical forms as well as English data.</S>
    <S sid="28" ssid="22">Each word or phrase will be associated with a specific type-shifting rules and relaxations of the few lexemes that can be combined with a shared set CCG combinators to model spontaneous, unedited of general templates. sentences.</S>
    <S sid="29" ssid="23">Zettlemoyer and Collins (2009) extends We develop an approach to learning factored, this work to the case of learning in context depenprobabilistic CCG grammars for semantic pars- dent environments.</S>
    <S sid="30" ssid="24">Kwiatkowski et al. (2010) deing.</S>
    <S sid="31" ssid="25">Following previous work (Kwiatkowski et al., scribed an approach for language-independent learn2010), we make use of a higher-order unification ing that replaces the hand-specified templates with learning scheme that defines a space of CCG gram- a higher-order-unification-based lexical induction mars consistent with the (sentence, logical form) method, but their approach does not scale well to training pairs.</S>
    <S sid="32" ssid="26">However, instead of constructing challenging, unedited sentences.</S>
    <S sid="33" ssid="27">The learning apfully specified lexical items for the learned grammar, proach we develop for inducing factored lexicons is we automatically generate sets of lexemes and lexi- also language independent, but scales well to these cal templates to model each example.</S>
    <S sid="34" ssid="28">This is a dif- challenging sentences. ficult learning problem, since the CCG analyses that There have been a number of other approaches for learning semantic parsers, including ones based on machine translation techniques (Papineni et al., 1997; Ramaswamy and Kleindienst, 2000; Wong and Mooney, 2006), parsing models (Miller et al., 1996; Ge and Mooney, 2006; Lu et al., 2008), in1A related tactic is commonly used in wide-coverage CCG parsers derived from treebanks, such as work by Hockenmaier and Steedman (2002) and Clark and Curran (2007).</S>
    <S sid="35" ssid="29">These parsers make extensive use of category-changing unary rules, to avoid data sparsity for systematically related categories (such as those related by type-raising).</S>
    <S sid="36" ssid="30">We will automatically learn to represent these types of generalizations in the factored lexicon.</S>
    <S sid="37" ssid="31">1513 ductive logic programming algorithms (Zelle and Mooney, 1996; Thompson and Mooney, 2002; Tang and Mooney, 2000), probabilistic automata (He and Young, 2005, 2006), and ideas from string kernels and support vector machines (Kate and Mooney, 2006; Nguyen et al., 2006).</S>
    <S sid="38" ssid="32">More recent work has focused on training semantic parsers without supervision in the form of logical-form annotations.</S>
    <S sid="39" ssid="33">Clarke et al. (2010) and Liang et al.</S>
    <S sid="40" ssid="34">(2011) replace semantic annotations in the training set with target answers which are more easily available.</S>
    <S sid="41" ssid="35">Goldwasser et al. (2011) present work on unsupervised learning of logical form structure.</S>
    <S sid="42" ssid="36">However, all of these systems require significantly more domain and language specific initialization than the approach presented here.</S>
    <S sid="43" ssid="37">Other work has learnt semantic analyses from text in the context of interactions in computational environments (Branavan et al. (2010), Vogel and Jurafsky (2010)); text grounded in partial observations of a world state (Liang et al., 2009); and from raw text alone (Poon and Domingos, 2009, 2010).</S>
    <S sid="44" ssid="38">There is also related work that uses the CCG grammar formalism.</S>
    <S sid="45" ssid="39">Clark and Curran (2003) present a method for learning the parameters of a log-linear CCG parsing model from fully annotated normal&#8211;form parse trees.</S>
    <S sid="46" ssid="40">Watkinson and Manandhar (1999) describe an unsupervised approach for learning syntactic CCG lexicons.</S>
    <S sid="47" ssid="41">Bos et al. (2004) present an algorithm for building semantic representations from CCG parses but requires fully&#8211;specified CCG derivations in the training data.</S>
  </SECTION>
  <SECTION title="3 Overview of the Approach" number="2">
    <S sid="48" ssid="1">Here we give a formal definition of the problem and an overview of the learning approach.</S>
    <S sid="49" ssid="2">Problem We will learn a semantic parser that takes a sentences x and returns a logical form z representing its underlying meaning.</S>
    <S sid="50" ssid="3">We assume we have input data {(xi,zi)|i = 1...n} containing sentences xi and logical forms zi, for example xi =&#8220;Show me flights to Boston&#8221; and zi = &#955;x. flight(x)nto(x,bos).</S>
    <S sid="51" ssid="4">Model We will represent the parser as a factored, probabilistic CCG (PCCG) grammar.</S>
    <S sid="52" ssid="5">A traditional CCG lexical item would fully specify the syntax and semantics for a word (reviewed in Section 4).</S>
    <S sid="53" ssid="6">For example, Boston &#65533;- NP : bos represents the entry for the word &#8220;Boston&#8221; with syntactic category NP and meaning represented by the constant bos.</S>
    <S sid="54" ssid="7">Where a lexicon would usually list lexical items such as this, we instead use a factored lexicon (L,T) containing: We will make central use of this factored representation to provide a more compact representation of the lexicon that can be learned efficiently.</S>
    <S sid="55" ssid="8">The factored PCCG will also contain a parameter vector, &#952;, that defines a log-linear distribution over the possible parses y, conditioned on the sentence x.</S>
    <S sid="56" ssid="9">Learning Our approach for learning factored PCCGs extends the work of Kwiatkowski et al. (2010), as reviewed in Section 7.</S>
    <S sid="57" ssid="10">Specifically, we modify the lexical learning, to produce lexemes and templates, as well as the feature space of the model, but reuse the existing parameter estimation techniques and overall learning cycle, as described in Section 7.</S>
    <S sid="58" ssid="11">We present the complete approach in three parts by describing the factored representation of the lexicon (Section 5), techniques for proposing potential new lexemes and templates (Section 6), and finally a complete learning algorithm (Section 7).</S>
    <S sid="59" ssid="12">However, the next section first reviews the required background on semantic parsing with CCG.</S>
  </SECTION>
  <SECTION title="4 Background" number="3">
    <S sid="60" ssid="1">We represent the meanings of sentences, words and phrases with logical expressions that can contain constants, quantifiers, logical connectors and lambda abstractions.</S>
    <S sid="61" ssid="2">We construct the meanings of sentences from the meanings of words and phrases using lambda-calculus operations.</S>
    <S sid="62" ssid="3">We use a version of the typed lambda calculus (Carpenter, 1997), in which the basic types include e, for entities; t, for truth values; and i for numbers.</S>
    <S sid="63" ssid="4">We also have function types that are assigned to lambda expressions.</S>
    <S sid="64" ssid="5">The expression &#955;x.flight(x) takes an entity and returns a truth value, and has the function type he,ti.</S>
    <S sid="65" ssid="6">CCG (Steedman, 1996, 2000) is a linguistic formalism that tightly couples syntax and semantics, and can be used to model a wide range of language phenomena.</S>
    <S sid="66" ssid="7">A traditional CCG grammar includes a lexicon &#923; with entries like the following: where each lexical item w`X : h has words w, a syntactic category X, and a logical form h. For the first example, these are &#8220;flights,&#8221; N, and &#955;x. flight(x).</S>
    <S sid="67" ssid="8">In this paper, we introduce a new way of representing lexical items as (lexeme, template) pairs, as described in section 5.</S>
    <S sid="68" ssid="9">CCG syntactic categories may be atomic (such as S or NP) or complex (such as (N\N)/NP) where the slash combinators encode word order information.</S>
    <S sid="69" ssid="10">CCG uses a small set of combinatory rules to build syntactic parses and semantic representations concurrently.</S>
    <S sid="70" ssid="11">Two example combinatory rules are forward (&gt;) and backward (&lt;) application: These rules apply to build syntactic and semantic derivations under the control of the word order information encoded in the slash directions of the lexical entries.</S>
    <S sid="71" ssid="12">For example, given the lexicon above, the phrase &#8220;flights to Boston&#8221; can be parsed to produce: flights to Boston These rules allow a relaxed notion of constituency which helps limit the number of distinct CCG lexical items required.</S>
    <S sid="72" ssid="13">To the standard forward and backward slashes of CCG we also add a vertical slash for which the direction of application is underspecified.</S>
    <S sid="73" ssid="14">We shall see examples of this in Section 10.</S>
    <S sid="74" ssid="15">Due to ambiguity in both the CCG lexicon and the order in which combinators are applied, there will be many parses for each sentence.</S>
    <S sid="75" ssid="16">We discriminate between competing parses using a log-linear model which has a feature vector &#966; and a parameter vector &#952;.</S>
    <S sid="76" ssid="17">The probability of a parse y that returns logical form z, given a sentence x is defined as: Section 8 fully defines the set of features used in the system presented.</S>
    <S sid="77" ssid="18">The most important of these control the generation of lexical items from (lexeme, template) pairs.</S>
    <S sid="78" ssid="19">Each (lexeme, template) pair used in a parse fires three features as we will see in more detail later.</S>
    <S sid="79" ssid="20">The parsing, or inference, problem done at test time requires us to find the most likely logical form z given a sentence x, assuming the parameters &#952; and lexicon &#923; are known: f (x) = argmax p(z|x;&#952;,&#923;) (2) z where the probability of the logical form is found by summing over all parses that produce it: where each step in the parse is labeled with the combinatory rule (&#8722; &gt; or &#8722; &lt;) that was used.</S>
    <S sid="80" ssid="21">CCG also includes combinatory rules of forward (&gt; B) and backward (&lt; B) composition: In this approach the distribution over parse trees y is modeled as a hidden variable.</S>
    <S sid="81" ssid="22">The sum over parses in Eq.</S>
    <S sid="82" ssid="23">3 can be calculated efficiently using the inside-outside algorithm with a CKY-style parsing algorithm.</S>
    <S sid="83" ssid="24">To estimate the parameters themselves, we use stochastic gradient updates (LeCun et al., 1998).</S>
    <S sid="84" ssid="25">Given a set of n sentence-meaning pairs {(xi,zi) : i = 1...n}, we update the parameters &#952; iteratively, for each example i, by following the local gradient of the conditional log-likelihood objective &lt; Oi = logP(zi|xi;&#952;,&#923;).</S>
    <S sid="85" ssid="26">The local gradient of the individual parameter &#952;j associated with feature &#966;j and training instance (xi,zi) is given by: As with Eq.</S>
    <S sid="86" ssid="27">3, all of the expectations in Eq.</S>
    <S sid="87" ssid="28">4 are calculated through the use of the inside-outside algorithm on a pruned parse chart.</S>
    <S sid="88" ssid="29">For a sentence of length m, each parse chart span is pruned using 2 a beam width proportional to m3 , to allow larger beams for shorter sentences.</S>
  </SECTION>
  <SECTION title="5 Factored Lexicons" number="4">
    <S sid="89" ssid="1">A factored lexicon includes a set L of lexemes and a set T of lexical templates.</S>
    <S sid="90" ssid="2">In this section, we formally define these sets, and describe how they are used to build CCG parses.</S>
    <S sid="91" ssid="3">We will use a set of lexical items from our running example to discuss the details of how the following lexical items: A lexeme (w,~c) pairs a word sequence w with an ordered list of logical constants c~ = [c1 ...cm].</S>
    <S sid="92" ssid="4">For example, item (1) and (2) above would come from a single lexeme (flight,[flight]).</S>
    <S sid="93" ssid="5">Similar lexemes would be represented for other predicates, for example (fare,[cost]).</S>
    <S sid="94" ssid="6">Lexemes also can contain multiple constants, for example (cheapest,[argmin,cost]), which we will see more examples of later.</S>
    <S sid="95" ssid="7">A lexical template takes a lexeme and produces a lexical item.</S>
    <S sid="96" ssid="8">Templates have the general form where h~v is a logical expression that contains variables from the list ~v.</S>
    <S sid="97" ssid="9">Applying this template to the input lexeme (w,~c) gives the full lexical item w ` X :h where the variable &#969; has been replaced with the wordspan w and the logical form h has been created by replacing each of the variables in~v with the counterpart constant from ~c.</S>
    <S sid="98" ssid="10">For example, the lexical item (6) above would be constructed from the lexeme (Boston,[bos]) using the template &#955;(&#969;,~v).</S>
    <S sid="99" ssid="11">[&#969; ` NP:v1].</S>
    <S sid="100" ssid="12">Items (1) and (2) would both be constructed from the single lexeme (flight,[flight]) with the two different templates &#955;(&#969;,~v).</S>
    <S sid="101" ssid="13">[&#969; ` N : &#955;x.v1(x)] and &#955;(&#969;,~v).</S>
    <S sid="102" ssid="14">[&#969; `N/(S|NP): &#955; f&#955;x.v1(x) &#8743; f (x)] In general, there can by many different (lexeme, template) pairs that produce the same lexical item.</S>
    <S sid="103" ssid="15">For example, lexical item (7) in our running example above can be constructed from the lexemes (Boston,[bos]) and (Boston,[from,bos]), given appropriate templates.</S>
    <S sid="104" ssid="16">To model this ambiguity, we include the selection of a (lexeme, template) pair as a decision to be made while constructing a CCG parse tree.</S>
    <S sid="105" ssid="17">Given the lexical item produced by the chosen lexeme and template, parsing continues with the traditional combinators, as reviewed in Section 4.2.</S>
    <S sid="106" ssid="18">This direct integration allows for features that signal which lexemes and templates have been used while also allowing for well defined marginal probabilities, by summing over all ways of deriving a specific lexical item.</S>
  </SECTION>
  <SECTION title="6 Learning Factored Lexicons" number="5">
    <S sid="107" ssid="1">To induce factored lexicons, we will make use of two procedures, presented in this section, that factor lexical items into lexemes and templates.</S>
    <S sid="108" ssid="2">Section 7 will describe how this factoring operation is integrated into the complete learning algorithm.</S>
    <S sid="109" ssid="3">Given a lexical item l of the form w `X : h with words w, a syntactic category X, and a logical form h, we define the maximal factoring to be the unique (lexeme, template) pair that can be used to reconstruct l and includes all of the constants of h in the lexeme (listed in a fixed order based on an ordered traversal of h).</S>
    <S sid="110" ssid="4">For example, the maximal factoring for the lexical item Boston ` NP : bos is the pair we saw before: (Boston,[bos]) and &#955;(&#969;,~v).</S>
    <S sid="111" ssid="5">[&#969; ` NP : v1].</S>
    <S sid="112" ssid="6">Similarly, the lexical item Boston ` N\N : &#955; f .&#955;x. f (x) &#8743; from(x,bos) would be factored to produce (Boston,[from,bos]) and &#955;(&#969;,~v).</S>
    <S sid="113" ssid="7">[&#969; ` N\N :&#955; f.&#955;x.f(x)&#8743;v1(x,v2)].</S>
    <S sid="114" ssid="8">As we will see in Section 7, this notion of factor&#8706;Oi &#8706;&#952;j ing can be directly incorporated into existing algorithms that learn CCG lexicons.</S>
    <S sid="115" ssid="9">When the original algorithm would have added an entry l to the lexicon, we can instead compute the factoring of l and add the corresponding lexeme and template to the factored lexicon.</S>
    <S sid="116" ssid="10">Maximal factorings, as just described, provide for significant lexical generalization but do not handle all of the cases needed to learn effectively.</S>
    <S sid="117" ssid="11">For instance, the maximal split for the item Boston ` N\N : &#955; f.&#955;x. f (x) &#8743; from(x,bos) would introduce the lexeme (Boston,[from,bos]), which is suboptimal since each possible city would need a lexeme of this type, with the additional from constant included.</S>
    <S sid="118" ssid="12">Instead, we would ideally like to learn the lexeme (Boston,[bos]) and have a template that introduces the from constant.</S>
    <S sid="119" ssid="13">This would model the desired generalization with a single lexeme per city.</S>
    <S sid="120" ssid="14">In order to permit the introduction of extra constants into lexical items, we allow the creation of templates that contain logical constants through partial factorings.</S>
    <S sid="121" ssid="15">For instance, the template below can introduce the predicate from &#955;(&#969;,v).</S>
    <S sid="122" ssid="16">[&#969; `N\N :&#955; f.&#955;x.f(x)&#8743; from(x,v1)] The use of templates to introduce extra semantic constants into a lexical item is similar to, but more general than, the English-specific type-shifting rules used in Zettlemoyer and Collins (2007), which were introduced to model spontaneous, unedited text.</S>
    <S sid="123" ssid="17">They are useful, as we will see, in learning to recover semantic content that is implied, but not explicitly stated, such as our original motivating phrase &#8220;flights Boston to New York.&#8221; To propose templates which introduce semantic content, during learning, we build on the intuition that we need to recover from missing words, such as in the example above.</S>
    <S sid="124" ssid="18">In this scenario, there should also be other sentences that actually include the word, in our example this would be something like &#8220;flights from Boston.&#8221; We will also assume that we have learned a good factored lexicon for the complete example that could produce the parse: flights from Boston Given analyses of this form, we introduce new templates that will allow us to recover from missing words, for example if &#8220;from&#8221; was dropped.</S>
    <S sid="125" ssid="19">We identify commonly occurring nodes in the best parse trees found during training, in this case the nonterminal spanning &#8220;from Boston,&#8221; and introduce templates that can produce the nonterminal, even if one of the words is missing.</S>
    <S sid="126" ssid="20">Here, this approach would introduce the desired template &#955;(&#969;,v).</S>
    <S sid="127" ssid="21">[&#969; ` N\N : &#955; f .&#955;x. f (x) &#8743; from(x,v1)] for mapping the lexeme (Boston,[bos]) directly to the intermediate structure.</S>
    <S sid="128" ssid="22">Not all templates introduced this way will model valid generalizations.</S>
    <S sid="129" ssid="23">However, we will incorporate them into a learning algorithm with indicator features that can be weighted to control their use.</S>
    <S sid="130" ssid="24">The next section presents the complete approach.</S>
  </SECTION>
  <SECTION title="7 Learning Factored PCCGs" number="6">
    <S sid="131" ssid="1">Our Factored Unification Based Learning (FUBL) method extends the UBL algorithm (Kwiatkowski et al., 2010) to induce factored lexicons, while also simultanously estimating the parameters of a loglinear CCG parsing model.</S>
    <S sid="132" ssid="2">In this section, we first review the NEW-LEX lexical induction procedure from UBL, and then present the FUBL algorithm.</S>
    <S sid="133" ssid="3">NEW-LEX generates lexical items by splitting and merging nodes in the best parse tree of each training example.</S>
    <S sid="134" ssid="4">Each parse node has a CCG category X : h and a sequence of words w that it spans.</S>
    <S sid="135" ssid="5">We will present an overview of the approach using the running example with the phrase w =&#8220;in Boston&#8221; and the category X : h = S\NP : &#955;x.loc(x,bos), which is of the type commonly seen during learning.</S>
    <S sid="136" ssid="6">The splitting procedure is a two step process that first splits the logical form h, then splits the CCG syntactic category X and finally splits the string w. The first step enumerates all possible splits of the logical form h into a pair of new expressions (f,g) that can be used to reconstruct h by either function application (h = f (g)) or composition (h = &#955;x. f (g(x))).</S>
    <S sid="137" ssid="7">For example, one possible split is: (f = &#955;y.&#955;x.loc(x,y) , g = bos) which corresponds to the function application case.</S>
    <S sid="138" ssid="8">The next two steps enumerate all ways of splitting the syntactic category X and words w to introduce two new lexical items which can be recombined with CCG combinators (application or composition) to recreate the original parse node X : h spanning w. In our example, one possibility would be: which could be recombined with the forward application combinator from Section 4.2.</S>
    <S sid="139" ssid="9">To assign categories while splitting, the grammar used by NEW-LEX only uses two atomic syntactic categories S and NP.</S>
    <S sid="140" ssid="10">This allows NEW-LEX to make use of a direct mapping from semantic type to syntactic category when proposing syntactic categories.</S>
    <S sid="141" ssid="11">In this schema, the standard syntactic category N is replaced by the category S|NP which matches the type he,ti and uses the vertical slash introduced in Section 4.2.</S>
    <S sid="142" ssid="12">We will see categories such as this in the evaluation.</S>
    <S sid="143" ssid="13">Figure 1 shows the FUBL learning algorithm.</S>
    <S sid="144" ssid="14">We assume training data {(xi,zi) : i = 1...n} where each example is a sentence xi paired with a logical form zi.</S>
    <S sid="145" ssid="15">The algorithm induces a factored PCCG, including the lexemes L, templates T, and parameters &#952;.</S>
    <S sid="146" ssid="16">The algorithm is online, repeatedly performing both lexical expansion (Step 1) and a parameter update (Step 2) for each training example.</S>
    <S sid="147" ssid="17">The overall approach is closely related to the UBL algorithm (Kwiatkowski et al., 2010), but includes extensions for updating the factored lexicon, as motivated in Section 6.</S>
    <S sid="148" ssid="18">Initialization The model is initialized with a factored lexicon as follows.</S>
    <S sid="149" ssid="19">MAX-FAC is a function that takes a lexical item l and returns the maximal factoring of it, that is the unique, maximal (lexeme, template) pair that can be combined to construct l, as described in Section 6.1.</S>
    <S sid="150" ssid="20">We apply MAX-FAC to each of the training examples (xi,zi), creating a single way of producing the desired meaning zi from a Inputs: Training set {(xi,zi) : i = 1...n} where each example is a sentence xi paired with a logical form zi.</S>
    <S sid="151" ssid="21">Set of entity name lexemes Le.</S>
    <S sid="152" ssid="22">Number of iterations J.</S>
    <S sid="153" ssid="23">Learning rate parameter &#945;0 and cooling rate parameter c. Empty lexeme set L. Empty template set T. Definitions: NEW-LEX(y) returns a set of new lexical items from a parse y as described in Section 7.1.</S>
    <S sid="154" ssid="24">MAX-FAC(l) generates a (lexeme, template) pair from a lexical item l. PART-FAC(y) generates a set of templates from parse y.</S>
    <S sid="155" ssid="25">Both of these are described in Section 7.2.</S>
    <S sid="156" ssid="26">The distributions p(y|x,z;&#952;,(L,T)) and p(y,z|x;&#952;,(L,T)) are defined by the log-linear model described in Section 4.3.</S>
    <S sid="157" ssid="27">Initialization: lexeme containing all of the words in xi.</S>
    <S sid="158" ssid="28">The lexemes and templates created in this way provide the initial factored lexicon.</S>
    <S sid="159" ssid="29">Step 1 The first step of the learning algorithm in Figure 1 adds lexemes and templates to the factored model given by performing manipulations on the highest scoring correct parse y&#8727; of the current training example (xi,zi).</S>
    <S sid="160" ssid="30">First the NEW-LEX procedure is run on y&#8727; as described in Section 6.1 to generate new lexical items.</S>
    <S sid="161" ssid="31">We then use the function MAX-FAC to create the maximal factorings of each of these new lexical items as described in Section 6 and these are added to the factored representation of the lexicon.</S>
    <S sid="162" ssid="32">New templates can also be introduced through partial factorings of internal parse nodes as described in Section 6.2.</S>
    <S sid="163" ssid="33">These templates are generated by using the function PART-FAC to abstract over the wordspan and a subset of the constants contained in the internal parse nodes of y&#8727;.</S>
    <S sid="164" ssid="34">This step allows for templates that introduce new semantic content to model elliptical language, as described in Section 6.2.</S>
    <S sid="165" ssid="35">Step 2 The second step does a stochastic gradient descent update on the parameters &#952; used in the parsing model.</S>
    <S sid="166" ssid="36">This update is described in Section 4.3 Discussion The FUBL algorithm makes use of a direct online approach, where lexemes and templates are introduced in place while analyzing specific sentences.</S>
    <S sid="167" ssid="37">In general, this will overgeneralize; not all ways of combining lexemes and templates will produce high quality lexical items.</S>
    <S sid="168" ssid="38">However, the overall approach includes features, presented in Section 8, that can be used to learn which ones are best in practice.</S>
    <S sid="169" ssid="39">The complete algorithm iterates between adding new lexical content and updating the parameters of the parsing model with each procedure guiding the other.</S>
  </SECTION>
  <SECTION title="8 Experimental setup" number="7">
    <S sid="170" ssid="1">Data Sets We evaluate on two benchmark semantic parsing datasets: GeoQuery, which is made up of natural language queries to a database of geographical information; and Atis, which contains natural language queries to a flight booking system.</S>
    <S sid="171" ssid="2">The Geo880 dataset has 880 (English-sentence, logicalform) pairs split into a training set of 600 pairs and a test set of 280.</S>
    <S sid="172" ssid="3">The Geo250 data is a subset of the Geo880 sentences that have been translated into Japanese, Spanish and Turkish as well as the original English.</S>
    <S sid="173" ssid="4">We follow the standard evaluation procedure for Geo250, using 10-fold cross validation experiments with the same splits of the data as Wong and Mooney (2007).</S>
    <S sid="174" ssid="5">The Atis dataset contains 5410 (sentence, logical-form) pairs split into a 4480 example training set, a 480 example development set and a 450 example test set.</S>
    <S sid="175" ssid="6">Evaluation Metrics We report exact match Recall (percentage of sentences for which the correct logical-form was returned), Precision (percentage of returned logical-forms that are correct) and F1 (harmonic mean of Precision and Recall).</S>
    <S sid="176" ssid="7">For Atis we also report partial match Recall (percentage of correct literals returned), Precision (percentage of returned literals that are correct) and F1, computed as described by Zettlemoyer and Collins (2007).</S>
    <S sid="177" ssid="8">Features We introduce two types of features to discriminate between parses: lexical features and logical-form features.</S>
    <S sid="178" ssid="9">Lexical features fire on the lexemes and templates used to build the lexical items used in a parse.</S>
    <S sid="179" ssid="10">For each (lexeme,template) pair used to create a lexical item we have indicator features &#966;l for the lexeme used, &#966;t for the template used, and &#966;(l,t) for the pair that was used.</S>
    <S sid="180" ssid="11">We assign the features on lexical templates a weight of 0.1 to prevent them from swamping the far less frequent but equally informative lexeme features.</S>
    <S sid="181" ssid="12">Logical-form features are computed on the lambda-calculus expression z returned at the root of the parse.</S>
    <S sid="182" ssid="13">Each time a predicate p in z takes an argument a with type Ty(a) in position i, it triggers two binary indicator features: &#966;(p,a,i) for the predicate-argument relation; and &#966;(p,Ty(a),i) for the predicate argument-type relation.</S>
    <S sid="183" ssid="14">Boolean operator features look at predicates that occurr together in conjunctions and disjunctions.</S>
    <S sid="184" ssid="15">For each variable vi that fills argument slot i in two conjoined predicates p1 and p2 we introduce a binary indicator feature &#966;conj(i,p1,p2).</S>
    <S sid="185" ssid="16">We introduce similar features &#966;disj(i,p1,p2) for variables vi that are shared by predicates in a disjunction.</S>
    <S sid="186" ssid="17">Initialization The weights for lexeme features are initialized according to coocurrance statistics between words and logical constants.</S>
    <S sid="187" ssid="18">These are estimated with the Giza++ (Och and Ney, 2003) implementation of IBM Model 1.</S>
    <S sid="188" ssid="19">The initial weights for templates are set by adding &#8722;0.1 for each slash in the syntactic category and &#8722;2 if the template contains logical constants.</S>
    <S sid="189" ssid="20">Features on lexeme-template pairs and all parse features are initialized to zero.</S>
    <S sid="190" ssid="21">Systems We compare performance to all recentlypublished, directly-comparable results.</S>
    <S sid="191" ssid="22">For GeoQuery, this includes the ZC05, ZC07 (Zettlemoyer and Collins, 2005, 2007), &#955;-WASP (Wong and Mooney, 2007), UBL (Kwiatkowski et al., 2010) systems and DCS (Liang et al., 2011).</S>
    <S sid="192" ssid="23">For Atis, we report results from HY06 (He and Young, 2006), ZC07, and UBL.</S>
  </SECTION>
  <SECTION title="9 Results" number="8">
    <S sid="193" ssid="1">Tables 1-4 present the results on the Atis and Geoquery domains.</S>
    <S sid="194" ssid="2">In all cases, FUBL achieves at or near state-of-the-art recall (overall number of correct parses) when compared to directly comparable systems and it significantly outperforms UBL on Atis.</S>
    <S sid="195" ssid="3">On Geo880 the only higher recall is achieved by DCS with prototypes - which uses significant English-specific resources, including manually specified lexical content, but does not require training sentences annotated with logical-forms.</S>
    <S sid="196" ssid="4">On Geo250, FUBL achieves the highest recall across languages.</S>
    <S sid="197" ssid="5">Each individual result should be interpreted with care, as a single percentage point corresponds to 2-3 sentences, but the overall trend is encouraging.</S>
    <S sid="198" ssid="6">On the Atis development set, FUBL outperforms ZC07 by 7.5% of recall but on the Atis test set FUBL lags ZC07 by 2%.</S>
    <S sid="199" ssid="7">The reasons for this discrepancy are not clear, however, it is possible that the syntactic constructions found in the Atis test set do not exhibit the same degree of variation as those seen in the development set.</S>
    <S sid="200" ssid="8">This would negate the need for the very general lexicon learnt by FUBL.</S>
    <S sid="201" ssid="9">Across the evaluations, despite achieving high recall, FUBL achieves significantly lower precision than ZC07 and &#955;-WASP.</S>
    <S sid="202" ssid="10">This illustrates the tradeoff from having a very general model of proposing lexical structure.</S>
    <S sid="203" ssid="11">With the ability to skip unseen words, FUBL returns a parse for all of the Atis test sentences, since the factored lexicons we are learning can produce a very large number of lexical items.</S>
    <S sid="204" ssid="12">These parses are, however, not always correct.</S>
  </SECTION>
  <SECTION title="10 Analysis" number="9">
    <S sid="205" ssid="1">The Atis results in Tables 1 and 2 highlight the advantages of factored lexicons.</S>
    <S sid="206" ssid="2">FUBL outperforms the UBL baseline by 16 and 11 points respectively in exact-match recall.</S>
    <S sid="207" ssid="3">Without making any modification to the CCG grammars or parsing combinators, we are able to induce a lexicon that is general enough model the natural occurring variations in the data, for example due to sloppy, unedited sentences.</S>
    <S sid="208" ssid="4">Figure 2 shows a parse returned by FUBL for a sentence on which UBL failed.</S>
    <S sid="209" ssid="5">While the word &#8220;cheapest&#8221; is seen 208 times in the training data, in only a handful of these instances is it seen in the middle of an utterance.</S>
    <S sid="210" ssid="6">For this reason, UBL never proposes the lexical item, cheapest &#65533;- NP\(S|NP)/(S|NP) : &#955; f&#955;g.argmin(&#955;x.f(x)ng(x),&#955;y.cost(y)), which is used to parse the sentence in Figure 2.</S>
    <S sid="211" ssid="7">In contrast, FUBL uses a lexeme learned from the same word in different contexts, along with a template learnt from similar words in a similar context, to learn to perform the desired analysis.</S>
    <S sid="212" ssid="8">As well as providing a new way to search the lexicon during training, the factored lexicon provides a way of proposing new, unseen, lexical items at test time.</S>
    <S sid="213" ssid="9">We find that new, non-NP, lexical items are used in 6% of the development set parses.</S>
    <S sid="214" ssid="10">Interestingly, the addition of templates that introduce semantic content (as described in Section 6.2) account for only 1.2% of recall on the Atis development set.</S>
    <S sid="215" ssid="11">This is suprising as elliptical constructions are found in a much larger proportion of the sentences than this.</S>
    <S sid="216" ssid="12">In practice, FUBL learns to model many elliptical constructions with lexemes and templates introduced through maximal factorings.</S>
    <S sid="217" ssid="13">For example, the lexeme (to,[from,to]) can be used with the correct lexical template to deal with our motivating example &#8220;flights Boston to New York&#8221;.</S>
    <S sid="218" ssid="14">Templates that introduce content are therefore only used in truly novel elliptical constructions for which an alternative analysis could not be learned.</S>
    <S sid="219" ssid="15">Table 5 shows a selection of lexemes and templates learned for Atis.</S>
    <S sid="220" ssid="16">Examples 2 and 3 show that morphological variants of the same word must still be stored in separate lexemes.</S>
    <S sid="221" ssid="17">However, as these lexemes now share templates, the total number of lexical variants that must be learned is reduced.</S>
  </SECTION>
  <SECTION title="11 Discussion" number="10">
    <S sid="222" ssid="1">We argued that factored CCG lexicons, which include both lexemes and lexical templates, provide a compact representation of lexical knowledge that can have advantages for learning.</S>
    <S sid="223" ssid="2">We also described a complete approach for inducing factored, probabilistic CCGs for semantic parsing, and demonstrated strong performance across a wider range of benchmark datasets that any previous approach.</S>
    <S sid="224" ssid="3">In the future, it will also be important to explore morphological models, to better model variation within the existing lexemes.</S>
    <S sid="225" ssid="4">The factored lexical representation also has significant potential for lexical transfer learning, where we would need to learn new lexemes for each target application, but much of the information in the templates could, potentially, be ported across domains.</S>
  </SECTION>
  <SECTION title="Acknowledgements" number="11">
    <S sid="226" ssid="1">The work was supported in part by EU ERC Advanced Fellowship 249520 GRAMPLUS, and an ESPRC PhD studentship.</S>
    <S sid="227" ssid="2">We would like to thank Yoav Artzi for helpful discussions.</S>
  </SECTION>
</PAPER>
