<PAPER>
  <S sid="0">Incremental Non-Projective Dependency Parsing</S>
  <ABSTRACT>
    <S sid="1" ssid="1">An open issue in data-driven dependency parsing is how to handle non-projective dependencies, which seem to be required by linguistically adequate representations, but which pose problems in parsing with respect to both accuracy and efficiency.</S>
    <S sid="2" ssid="2">Using data from five different languages, we evaluate an incremental deterministic parser that derives non-projective depenstructures in supported by SVM classifiers for predicting the next parser action.</S>
    <S sid="3" ssid="3">The experiments show that unrestricted non-projective parsing gives a significant improvement in accuracy, compared to a strictly projective baseline, with up to 35% error reduction, leading to state-of-the-art results for the given data sets.</S>
    <S sid="4" ssid="4">Moreover, by restricting the class of permissible structures to limited degrees of non-projectivity, the parsing time can be reduced by up to 50% without a significant decrease in accuracy.</S>
  </ABSTRACT>
  <SECTION title="1 Introduction" number="1">
    <S sid="5" ssid="1">Data-driven dependency parsing has been shown to give accurate and efficient parsing for a wide range of languages, such as Japanese (Kudo and Matsumoto, 2002), English (Yamada and Matsumoto, 2003), Swedish (Nivre et al., 2004), Chinese (Cheng et al., 2004), and Czech (McDonald et al., 2005).</S>
    <S sid="6" ssid="2">Whereas most of the early approaches were limited to strictly projective dependency structures, where the projection of a syntactic head must be continuous, attention has recently shifted to the analysis of non-projective structures, which are required for linguistically adequate representations, especially in languages with free or flexible word order.</S>
    <S sid="7" ssid="3">The most popular strategy for capturing nonprojective structures in data-driven dependency parsing is to apply some kind of post-processing to the output of a strictly projective dependency parser, as in pseudo-projective parsing (Nivre and Nilsson, 2005), corrective modeling (Hall and Nov&#180;ak, 2005), or approximate non-projective parsing (McDonald and Pereira, 2006).</S>
    <S sid="8" ssid="4">And it is rare to find parsers that derive non-projective structures directly, the notable exception being the non-projective spanning tree parser proposed by McDonald et al. (2005).</S>
    <S sid="9" ssid="5">There are essentially two arguments that have been advanced against using parsing algorithms that derive non-projective dependency structures directly.</S>
    <S sid="10" ssid="6">The first is that the added expressivity compromises efficiency, since the parsing problem for a grammar that allows arbitrary non-projective dependency structures has been shown to be NP complete (Neuhaus and Br&#168;oker, 1997).</S>
    <S sid="11" ssid="7">On the other hand, most data-driven approaches do not rely on grammars, and with a suitable factorization of dependency structures, it is possible to achieve parsing of unrestricted non-projective structures in O(n2) time, as shown by McDonald et al. (2005).</S>
    <S sid="12" ssid="8">The second argument against non-projective dependency parsing comes from the observation that, even in languages with free or flexible word order, most dependency structures are either projective or very nearly projective.</S>
    <S sid="13" ssid="9">This can be seen by considering data from treebanks, such as the Prague Dependency Treebank of Czech (B&#168;ohmov&#180;a et al., 2003), the TIGER Treebank of German (Brants et al., 2002), or the Slovene Dependency Treebank (D&#711;zeroski et al., 2006), where the overall proportion of non-projective dependencies is only about 2% even though the proportion of sentences that contain some non-projective dependency is as high as 25%.</S>
    <S sid="14" ssid="10">This means that an approach that starts by deriving the best projective approximation of the correct dependency structure is likely to achieve high accuracy, while an approach that instead attempts to search the complete space of non-projective dependency structures runs the risk of finding structures that depart too much from the near-projective norm.</S>
    <S sid="15" ssid="11">Again, however, the results of McDonald et al. (2005) suggest that the latter risk is minimized if inductive learning is used to guide the search.</S>
    <S sid="16" ssid="12">One way of improving efficiency, and potentially also accuracy, in non-projective dependency parsing is to restrict the search to a subclass of &#8220;mildly nonprojective&#8221; structures.</S>
    <S sid="17" ssid="13">Nivre (2006) defines degrees of non-projectivity in terms of the maximum number of intervening constituents in the projection of a syntactic head and shows that limited degrees of nonprojectivity give a much better fit with the linguistic data than strict projectivity, but also enables more efficient processing than unrestricted non-projectivity.</S>
    <S sid="18" ssid="14">However, the results presented by Nivre (2006) are all based on oracle parsing, which means that they only provide upper bounds on the accuracy that can be achieved.</S>
    <S sid="19" ssid="15">In this paper, we investigate to what extent constraints on non-projective structures can improve accuracy and efficiency in practical parsing, using treebank-induced classifiers to predict the actions of a deterministic incremental parser.</S>
    <S sid="20" ssid="16">The parsing algorithm used belongs to the family of algorithms described by Covington (2001), and the classifiers are trained using support vector machines (SVM) (Vapnik, 1995).</S>
    <S sid="21" ssid="17">The system is evaluated using treebank data from five languages: Danish, Dutch, German, Portuguese, and Slovene.</S>
    <S sid="22" ssid="18">The paper is structured as follows.</S>
    <S sid="23" ssid="19">Section 2 defines syntactic representations as labeled dependency graphs and introduces the notion of degree used to constrain the search.</S>
    <S sid="24" ssid="20">Section 3 describes the parsing algorithm, including modifications necessary to handle degrees of non-projectivity, and section 4 describes the data-driven prediction of parser actions, using history-based models and SVM classifiers.</S>
    <S sid="25" ssid="21">Section 5 presents the experimental setup, section 6 discusses the experimental results, and section 7 contains our conclusions.</S>
  </SECTION>
  <SECTION title="2 Dependency Graphs" number="2">
    <S sid="26" ssid="1">A dependency graph is a labeled directed graph, the nodes of which are indices corresponding to the tokens of a sentence.</S>
    <S sid="27" ssid="2">Formally: Definition 1 Given a set R of dependency types (arc labels), a dependency graph for a sentence The set V of nodes (or vertices) is the set of nonnegative integers up to and including n. This means that every token index i of the sentence is a node (1 G i G n) and that there is a special node 0, which will always be a root of the dependency graph.</S>
    <S sid="28" ssid="3">The set E of arcs (or edges) is a set of ordered pairs (i, j), where i and j are nodes.</S>
    <S sid="29" ssid="4">Since arcs are used to represent dependency relations, we will say that i is the head and j is the dependent of the arc (i, j).</S>
    <S sid="30" ssid="5">The function L assigns a dependency type (label) r E R to every arc e E E. We use the notation i &#8212;* j to mean that there is an arc connecting i and j (i.e., (i, j) E E); we use the notation i &#8212;*r j if this arc is labeled r (i.e., ((i, j), r) E L); and we use the notation i &#8212;** j and i H* j for the reflexive and transitive closure of the arc relation E and the corresponding undirected relation, respectively.</S>
    <S sid="31" ssid="6">The well-formedness conditions are independent in that none of them is entailed by any (combination) of the others, but they jointly entail that the graph is a tree rooted at the node 0.</S>
    <S sid="32" ssid="7">By way of example, figure 1 shows a Czech sentence from the Prague Dependency Treebank (B&#168;ohmov&#180;a et al., 2003) with a well-formed dependency graph according to Definitions 1 and 2.</S>
    <S sid="33" ssid="8">The constraints imposed on dependency graphs in Definition 2 are assumed in almost all versions of dependency grammar, especially in computational systems, and are sometimes complemented by a fourth constraint: 4.</S>
    <S sid="34" ssid="9">The graph G is projective, i.e., if i &#8212;* j then i &#8212;** k, for every node k such that i &lt; k &lt; j or j &lt; k &lt; i (PROJECTIVITY).</S>
    <S sid="35" ssid="10">Most theoretical formulations of dependency grammar regard projectivity as the norm but recognize the need for non-projective representations to capture non-local dependencies (Mel&#8217;&#711;cuk, 1988; Hudson, 1990).</S>
    <S sid="36" ssid="11">Finding a way of incorporating a suitably restricted notion of non-projectivity into practical parsing systems is therefore an important step towards a more adequate syntactic analysis, as discussed in the introduction of this paper.</S>
    <S sid="37" ssid="12">In order to distinguish classes of dependency graphs that fall in between arbitrary non-projective and projective, Nivre (2006) introduces a notion of degree of non-projectivity, such that projective graphs have degree 0 while arbitrary non-projective graphs have unbounded degree.</S>
    <S sid="38" ssid="13">Definition 3 Let G = (V, E, L) be a well-formed dependency graph, let G(i,j) be the subgraph of G defined by V(i,j) = {i, i + 1, ... , j &#8722;1, j}, and let min(e) be the smallest and max(e) the largest element of an arc e in the linear order &lt;: To exemplify the notion of degree, we note that the dependency graph in figure 1 has degree 1.</S>
    <S sid="39" ssid="14">The only non-projective arc in the graph is (5, 1) and G(2,4) contains three connected components, each consisting of a single root node (2, 3, 4).</S>
    <S sid="40" ssid="15">Since exactly one of these, 3, is not dominated by 5 in G(1,5), the arc (5, 1) has degree 1.</S>
    <S sid="41" ssid="16">Nivre (2006) presents an empirical study, based on data from the Prague Dependency Treebank of Czech (B&#168;ohmov&#180;a et al., 2003) and the Danish Dependency Treebank (Kromann, 2003), showing that more than 99.5% of all sentences occurring in the two treebanks have a dependency graph with a maximum degree of 2; about 98% have a maximum degree of 1; but only 77% in the Czech data and 85% in the Danish data have degree 0 (which is equivalent to assuming PROJECTIVITY).</S>
    <S sid="42" ssid="17">This suggests that limited degrees of non-projectivity may allow a parser to capture a larger class of naturally occurring syntactic structures, while still constraining the search to a proper subclass of all possible structures.1</S>
  </SECTION>
  <SECTION title="3 Parsing Algorithm" number="3">
    <S sid="43" ssid="1">Covington (2001) describes a parsing strategy for dependency representations that has been known since the 1960s but not presented in the literature.</S>
    <S sid="44" ssid="2">The left-to-right (or incremental) version of this strategy can be formulated in the following way: LINK(i, j) is a nondeterministic operation that adds the arc i &#8212;* j (with some label), adds the arc j &#8212;* i (with some label), or does nothing at all.</S>
    <S sid="45" ssid="3">In this way, the algorithm builds a graph by systematically trying to link every pair of nodes (i, j) (i &lt; j).</S>
    <S sid="46" ssid="4">We assume that LINK(i,j) respects the ROOT and SINGLE-HEAD constraints and that it does not introduce cycles into the graph, i.e., it adds an arc k j, and it is not the case that j &#8212;** i.</S>
    <S sid="47" ssid="5">Given these constraints, the graph G given at termination can always be turned into a well-formed dependency graph by adding arcs from the root 0 to any root node in {1, ... , n}.</S>
    <S sid="48" ssid="6">Assuming that LINK(i, j) can be performed in some constant time c, the running time of the algorithm is En i=1 c(i &#8722; 1) = c(n&#65533;2 &#8722; n2 ), which in terms of asymptotic complexity is 0(n2).</S>
    <S sid="49" ssid="7">Checking ROOT and SINGLE-HEAD in constant time is easy, but in order to prevent cycles we need to be able to find, for any node k, the root of the connected component to which k belongs in the partially built graph.</S>
    <S sid="50" ssid="8">This problem can be solved efficiently using standard techniques for disjoint sets, including path compression and union by rank, which guarantee that the necessary checks can be performed in average constant time (Cormen et al., 1990).</S>
    <S sid="51" ssid="9">In the experiments reported in this paper, we modify the basic algorithm by making the performance of LINK(i, j) conditional on the arcs (i, j) and (j, i) being permissible under different degree constraints: The function PERMISSIBLE(i, j, d) returns true if and only if i &#8212;* j and j &#8212;* i have a degree less than or equal to d given the partially built graph G. Setting d = 0 gives strictly projective parsing, while d = oc corresponds to unrestricted non-projective parsing.</S>
    <S sid="52" ssid="10">With low values of d, we will reduce the number of calls to LINK(i, j), which will reduce the overall parsing time provided that the time required to compute PERMISSIBLE(i, j, d) is insignificant compared to the time needed for LINK(i, j).</S>
    <S sid="53" ssid="11">This is typically the case in data-driven systems, where LINK(i, j) requires a call to a trained classifier, while PERMISSIBLE(i, j, d) only needs access to the partially built graph G.2</S>
  </SECTION>
  <SECTION title="4 History-Based Parsing" number="4">
    <S sid="54" ssid="1">History-based parsing uses features of the parsing history to predict the next parser action (Black et al., 1992).</S>
    <S sid="55" ssid="2">In the current setup, this involves using features of the partially built dependency graph G and the input x = (w1, ... , wn) to predict the outcome of the nondeterministic LINK(i, j) operation.</S>
    <S sid="56" ssid="3">Given that we use a deterministic parsing strategy, this reduces to a pure classification problem.</S>
    <S sid="57" ssid="4">Let -b(i, j, G) = (01,... ,0m) be a feature vector representation of the parser history at the time of performing LINK(i, j).</S>
    <S sid="58" ssid="5">The task of the historybased classifier is then to map 4b(i, j, G) to one of the following actions: Training data for the classifier can be generated by running the parser on a sample of treebank data, using the gold standard dependency graph as an oracle to predict LINK(i, j) and constructing one training instance (4b(i, j, G), a) for each performance of LINK(i, j) with outcome a.</S>
    <S sid="59" ssid="6">The features in 4b(i, j, G) = (01, ... , Om) can be arbitrary features of the input x and the partially built graph G but will in the experiments below be restricted to linguistic attributes of input tokens, including their dependency types according to G. per sentence (mean); Lem = lemmatization present; CPoS = number of coarse-grained part-of-speech tags; PoS = number of (fine-grained) part-of-speech tags; MSF = number of morphosyntactic features (split into atoms); Dep = number of dependency types; NPT = proportion of non-projective dependencies/tokens (%); NPS = proportion of non-projective dependency graphs/sentences (%) The history-based classifier can be trained with any of the available supervised methods for function approximation, but in the experiments below we will rely on SVM, which has previously shown good performance for this kind of task (Kudo and Matsumoto, 2002; Yamada and Matsumoto, 2003).</S>
  </SECTION>
  <SECTION title="5 Experimental Setup" number="5">
    <S sid="60" ssid="1">The purpose of the experiments is twofold.</S>
    <S sid="61" ssid="2">First, we want to investigate whether allowing non-projective structures to be derived incrementally can improve parsing accuracy compared to a strictly projective baseline.</S>
    <S sid="62" ssid="3">Secondly, we want to examine whether restricting the degree of non-projectivity can improve efficiency compared to an unrestricted nonprojective baseline.</S>
    <S sid="63" ssid="4">In order to investigate both these issues, we have trained one non-projective parser for each language, allowing arbitrary non-projective structures as found in the treebanks during training, but applying different constraints during parsing: These three versions of the non-projective parser are compared to a strictly projective parser (d = 0), which uses the same parsing algorithm but only considers projective arcs in both training and testing.3 The experiments are based on treebank data from five languages: the Danish Dependency Treebank 3An alternative would have been to train all parsers on nonprojective data, or restrict the training data for each parser according to its parsing restriction.</S>
    <S sid="64" ssid="5">Preliminary experiments showed that the setup used here gave the best performance for all parsers involved.</S>
    <S sid="65" ssid="6">(Kromann, 2003), the Alpino Treebank of Dutch (van der Beek et al., 2002), the TIGER Treebank of German (Brants et al., 2002), the Floresta Sint&#180;actica of Portuguese (Afonso et al., 2002), and the Slovene Dependency Treebank (D&#711;zeroski et al., 2006).4 The data sets used are the training sets from the CoNLLX Shared Task on multilingual dependency parsing (Buchholz and Marsi, 2006), with 20% of the data reserved for testing using a pseudo-random split.</S>
    <S sid="66" ssid="7">Table 1 gives an overview of the five data sets, showing the number of tokens and sentences, the presence of different kinds of linguistic annotation, and the amount of non-projectivity.</S>
    <S sid="67" ssid="8">The features used in the history-based model for all languages include the following core set of 20 features, where i and j are the tokens about to be linked and the context stack is a stack of root nodes k in G(i+1&#65533;j_1), added from right to left (i.e., with the top node being closest to i): In the specification of features, we use k and k&#8722;1 to refer to the two topmost tokens on the context stack, and we use h(&#945;), l(&#945;) and r(&#945;) to refer to the head, the leftmost dependent and the rightmost dependent of a token &#945; in the partially built dependency graph.5 In addition to the core set of features, the model for each language has been augmented with a small number of additional features, which have proven useful in previous experiments with the same data set.</S>
    <S sid="68" ssid="9">The maximum number of features used is 28 (Danish); the minimum number is 23 (German).</S>
    <S sid="69" ssid="10">The history-based classifiers have been trained using SVM learning, which combines a maximum margin strategy with the use of kernel functions to map the original feature space to a higherdimensional space.</S>
    <S sid="70" ssid="11">More specifically, we use LIBSVM (Chang and Lin, 2001) with a quadratic kernel K(xZ7 xj) _ (ryxT xj +r)2.</S>
    <S sid="71" ssid="12">We use the built-in oneversus-one strategy for multi-class classification and convert symbolic features to numerical features using the standard technique of binarization.</S>
    <S sid="72" ssid="13">Parsing accuracy is measured by the unlabeled attachment score (AS), i.e., the proportion of words that are assigned the correct head (not counting punctuation).</S>
    <S sid="73" ssid="14">Although the parsers do derive labeled dependency graphs, we concentrate on the graph structure here, since this is what is concerned in the distinction between projective and non-projective dependency graphs.</S>
    <S sid="74" ssid="15">Efficiency is evaluated by reporting the parsing time (PT), i.e., the time required to parse the respective test sets.</S>
    <S sid="75" ssid="16">Since both training sets and test sets vary considerably in size between languages, we are primarily interested in the relative differences for parsers applied to the same language.</S>
    <S sid="76" ssid="17">Experiments have been performed on a SunBlade 2000 with one 1.2GHz UltraSPARC-III processor and 2GB of memory.</S>
  </SECTION>
  <SECTION title="6 Results and Discussion" number="6">
    <S sid="77" ssid="1">Table 2 shows the parsing accuracy of the nonprojective parser with different maximum degrees, both the raw attachment scores and the amount of error reduction with respect to the baseline parser.</S>
    <S sid="78" ssid="2">Our first observation is that the non-projective parser invariably achieves higher accuracy than the projective baseline, with differences that are statistically significant across the board (using McNemar&#8217;s test).</S>
    <S sid="79" ssid="3">The amount of error reduction varies between languages and seems to depend primarily on the frequency of non-projective structures, which is not surprising.</S>
    <S sid="80" ssid="4">Thus, for Dutch and German, the two languages with the highest proportion of nonprojective structures, the best error reduction is over 35% and over 20%, respectively.</S>
    <S sid="81" ssid="5">However, there seems to be a sparse data effect in that Slovene, which has the smallest training data set, has the smallest error reduction despite having more nonprojective structures than Danish and Portuguese.</S>
    <S sid="82" ssid="6">Our second observation is that the highest score is always obtained with an unbounded degree of nonprojectivity during parsing.</S>
    <S sid="83" ssid="7">This seems to corroborate the results obtained by McDonald et al. (2005) with a different parsing method, showing that the use of inductive learning to guide the search during parsing eliminates the potentially harmful effect of increasing the size of the search space.</S>
    <S sid="84" ssid="8">Although the differences between different degrees of non-projectivity are not statistically significant for the current data sets,6 the remarkable consistency across languages suggests that they are nevertheless genuine.</S>
    <S sid="85" ssid="9">In either case, however, they must be considered marginal, except possibly for Dutch, which leads to our third and final observation about accu6The only exception is the difference between a maximum degree of 1 and unrestricted non-projective for Dutch, which is significant according to McNemar&#8217;s test with &#945;=.05. racy, namely that restricting the maximum degree of non-projectivity to 2 or 1 has a very marginal effect on accuracy and is always significantly better than the projective baseline.</S>
    <S sid="86" ssid="10">Turning next to efficiency, table 3 shows the parsing time for the different parsers across the five languages.</S>
    <S sid="87" ssid="11">Our first observation here is that the parsing time can be reduced by restricting the degree of non-projectivity during parsing, thus corroborating the claim that the running time of the historybased classifier dominates the overall parsing time.</S>
    <S sid="88" ssid="12">As expected, the largest reduction is obtained with the strictly projective parser, but here we must also take into account that the training data set is smaller (because of the restriction to projective potential links), which improves the average running time of the history-based classifier in itself.</S>
    <S sid="89" ssid="13">Our second observation is that the amount of reduction in parsing time seems to be roughly related to the amount of non-projectivity, with a reduction of about 50% at a max degree of 1 for the languages where more than 20% of all sentences are non-projective (Dutch, German, Slovene) but significantly smaller for Portuguese and especially for Danish.</S>
    <S sid="90" ssid="14">On the whole, however, the reduction in parsing time with limited degrees of non-projectivity is substantial, especially considering the very marginal drop in accuracy.</S>
    <S sid="91" ssid="15">In order to compare the performance to the state of the art in dependency parsing, we have retrained the non-projective parser on the entire training data set for each language and evaluated it on the final test set from the CoNLL-X shared task (Buchholz and Marsi, 2006).</S>
    <S sid="92" ssid="16">Thus, table 4 shows labeled attachment scores, the main evaluation metric used in the shared task, in comparison to the two highest scoring systems from the original evaluation (McDonald et al., 2006; Nivre et al., 2006).</S>
    <S sid="93" ssid="17">The incremental non-projective parser has the best reported score for Danish and outperforms at least one of the other two systems for four languages out of five, although most of the differences are probably too small to be statistically significant.</S>
    <S sid="94" ssid="18">But whereas the spanning tree parser of McDonald et al. (2006) and the pseudo-projective parser of Nivre et al.</S>
    <S sid="95" ssid="19">(2006) achieve this performance only with special pre- or post-processing,7 the approach presented here derives a labeled non-projective graph in a single incremental process and hence at least has the advantage of simplicity.</S>
    <S sid="96" ssid="20">Moreover, it has better time complexity than the approximate second-order spanning tree parsing of McDonald et al. (2006), which has exponential complexity in the worst case (although this does not appear to be a problem in practice).</S>
  </SECTION>
  <SECTION title="7 Conclusion" number="7">
    <S sid="97" ssid="1">In this paper, we have investigated a data-driven approach to dependency parsing that combines a deterministic incremental parsing algorithm with historybased SVM classifiers for predicting the next parser action.</S>
    <S sid="98" ssid="2">We have shown that, for languages with a non-negligible proportion of non-projective structures, parsing accuracy can be improved significantly by allowing non-projective structures to be derived.</S>
    <S sid="99" ssid="3">We have also shown that the parsing time can be reduced substantially, with only a marginal loss in accuracy, by limiting the degree of nonprojectivity allowed during parsing.</S>
    <S sid="100" ssid="4">A comparison with results from the CoNLL-X shared task shows that the parsing accuracy is comparable to that of the best available systems, which means that incremental non-projective dependency parsing is a viable alternative to approaches based on post-processing of projective approximations.</S>
  </SECTION>
  <SECTION title="Acknowledgments" number="8">
    <S sid="101" ssid="1">The research presented in this paper was partially supported by a grant from the Swedish Research Council.</S>
    <S sid="102" ssid="2">I want to thank Johan Hall and Jens Nilsson for their contributions to MaltParser, which was used to perform the experiments.</S>
    <S sid="103" ssid="3">I am also grateful to three anonymous reviewers for finding important errors in the preliminary version and for suggesting several other improvements for the final version.</S>
  </SECTION>
</PAPER>
