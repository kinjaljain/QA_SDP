Finite-State Non-Concatenative Morphotactics Finite-state morphology in the general tradition of the Two-Level and Xerox implementations has proved very successful in the production of robust morphological analyzer-generators, including many large-scale commercial systems. However, it has long been recognized that these implementations have serious limitations in handling non-concatenative phenomena. We describe a new technique for constructing finite- state transducers that involves reapplying the regular-expression compiler to its own output. Implemented in an algorithm called compile- replace, this technique has proved useful for handling non-concatenative phenomena; and we demonstrate it on Malay full-stem reduplication and Arabic stem interdigitation. The author describes a new technique for constructing finite- state transducers that involves reapplying the regular-expression compiler to its own output. Regular-expression descriptions are compiled into finite-state automata or transducers as usual, and then the compiler is re-applied to its own output, producing a modified but still finite- state network. The technique, implemented in an algorithm called compile-replace, has already proved useful for handling Malay full- stem reduplication and Arabic stem interdigitation. If the relation is finite-state, then it can be defined using the metalanguage of regular expressions; and, with a suitable compiler, the regular expression source code can be compiled into a finite-state transducer (FST). The application of the compile-replace algorithm to the lower side of the network eliminates the markers, compiles the regular expression a* and maps the upper side of the path to the language resulting from the compilation. The compile-replace algorithm is essentially a variant of a simple recursive-descent copying routine. Traditional Two-Level implementations are already capable of describing some limited reduplication and infixation as in Tagalog. The merge algorithm is a pattern-filling operation that combines two regular languages, a template and filler, into a single one. Work remains to be done in applying the technique to other known varieties of non-concatenative morphotactics. The compile-replace algorithm and the merge operator introduced in this paper are general techniques which are not limited to handling the specific morphotactic problems have been discussed. The author expects that they will have many other useful applications. This technique, implemented in an algorithm called compile-replace, has already proved useful for handling Malay full- stem reduplication and Arabic stem interdigitation, which will be described below. If the relation is finite-state, then it can be defined using the metalanguage of regular expressions; and, with a suitable compiler, the regular expression source code can be compiled into a finite-state transducer (fst), as shown in Figure 4, that implements the relation computationally. All the finite-state operations (concatenation, union, intersection, composition, etc.) can be simulated by an apply routine at runtime. The compile- replace algorithm then reapplies the regular- expression compiler to its own output, compiling the regular-expression substrings in the intermediate network and replacing them with the result of the compilation. In the regular expression calculus there are several operators that involve concatenation. In work more directly related to the current solution, it was Kataja and Koskenniemi (1988) who first demonstrated that Semitic (Akkadian) roots and patterns5 could be formalized as regular languages, and that the non-concatenative interdigitation of stems could be elegantly formalized as the intersection of those regular languages. 3.2.2 Merge The merge algorithm is a pattern-filling operation that combines two regular languages, a template and a filler, into a single one. The technique described here, implemented in the compile-replace algorithm, allows the regular-expression compiler to reapply to and modify its own output, effectively freeing morphotactic description to use any finite-state operation. This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime. Significant experiments with Malay and a much larger application in Arabic have shown the value of this technique in handling two classic examples of non-concatenative morphotactics: full-stem reduplication and Semitic stem interdigitation. The compile-replace algorithm and the merge operator introduced in this paper are general techniques not limited to handling the specific 