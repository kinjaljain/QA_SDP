Citance Number: 1 | Reference Article:  W06-1616.txt | Citing Article:  D07-1100.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >For dependency parsing, McDonald and Pereira (2006) proposed a method which can incorporate some types of global features, and Riedel and Clarke (2006) studied a method using integer linear programming which can incorporate global linguistic constraints.</S> | Reference Offset:  ['54','76'] | Reference Text:  <S sid = 54 ssid = >The method we present is not the only one that can take global constraints into account.</S><S sid = 76 ssid = >We alleviate this problem by presenting an equivalent Integer Linear Programming formulation which allows us to incorporate global constraints naturally.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 2 | Reference Article:  W06-1616.txt | Citing Article:  N09-2002.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >However, work in dependency parsing (Riedel and Clarke, 2006) has demonstrated that it is possible to use ILP to perform efficient inference for very large programs when used in an incremental manner.</S> | Reference Offset:  ['0','14'] | Reference Text:  <S sid = 0 ssid = >Incremental Integer Linear Programming For Non-Projective Dependency Parsing</S><S sid = 14 ssid = >However, it is not possible to use this approach directly for a complex task like non-projective dependency parsing due to the exponential number of constraints required to prevent cycles occurring in the dependency graph.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 3 | Reference Article:  W06-1616.txt | Citing Article:  N09-2002.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >However, recent work (Riedel and Clarke, 2006) has shown that even exponentially large decoding problems may be solved efficiently using ILP solvers if a Cutting-Plane Algorithm (Dantzig et al, 1954) is used.</S> | Reference Offset:  ['15','172'] | Reference Text:  <S sid = 15 ssid = >To model all these constraints explicitly would result in an ILP formulation too large to solve efficiently (Williams, 2002).</S><S sid = 172 ssid = >While we expect a longer runtime than using the Chu-Liu-Edmonds as in previous work (McDonald et al., 2005b), we are interested in how large the increase is.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 4 | Reference Article:  W06-1616.txt | Citing Article:  D10-1125.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Riedel and Clarke (2006) describe ILP methods for the problem; Martins et al (2009) recently introduced alternative LP and ILP formulations.</S> | Reference Offset:  ['16','57'] | Reference Text:  <S sid = 16 ssid = >A similar problem also occurs in an ILP formulation for machine translation which treats decoding as the Travelling Salesman Problem (Germann et al., 2001).</S><S sid = 57 ssid = >This is not the case when using ILP.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 5 | Reference Article:  W06-1616.txt | Citing Article:  N10-1117.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Riedel and Clarke (2006) tackled the MAP problem for dependency parsing by an incremental approach that starts with a relaxation of the problem, solves it, and adds additional constraints only if they are violated.</S> | Reference Offset:  ['3','89'] | Reference Text:  <S sid = 3 ssid = >We present an approach which solves the problem incrementally, thus we avoid creating intractable integer linear programs.</S><S sid = 89 ssid = >As a workaround for this problem we follow an incremental approach akin to the work of Warme (1998).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 6 | Reference Article:  W06-1616.txt | Citing Article:  D11-1012.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >ILPs have since been used successfully in many NLP applications involving complex structures Punyakanok et al (2008) for semantic role labeling, Riedel and Clarke (2006) and Martins et al (2009) for dependency parsing and several others.</S> | Reference Offset:  ['7','41'] | Reference Text:  <S sid = 7 ssid = >Strong assumptions are also made in the case of McDonald et al.â€™s (2005b) non-projective dependency parsing model.</S><S sid = 41 ssid = >Although less informative than lexicalised phrase structures, dependency structures still capture most of the predicate-argument information needed for applications.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 7 | Reference Article:  W06-1616.txt | Citing Article:  E09-1051.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Another attempt to overcome the problem of complexity with ILP models is described in (Riedel and Clarke, 2006) (dependency parsing).</S> | Reference Offset:  ['16','88'] | Reference Text:  <S sid = 16 ssid = >A similar problem also occurs in an ILP formulation for machine translation which treats decoding as the Travelling Salesman Problem (Germann et al., 2001).</S><S sid = 88 ssid = >We found out experimentally that dependency parsing models of this form do not converge on a solution after multiple hours of solving, even for small sentences.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 8 | Reference Article:  W06-1616.txt | Citing Article:  D08-1016.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >In contrast, generic NP-hard solution techniques like Integer Linear Programming (Riedel and Clarke, 2006) know nothing about optimal substructure.</S> | Reference Offset:  ['0','83'] | Reference Text:  <S sid = 0 ssid = >Incremental Integer Linear Programming For Non-Projective Dependency Parsing</S><S sid = 83 ssid = >Integer Linear Programming is an extension of linear programming where all decision variables must take integer values.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 9 | Reference Article:  W06-1616.txt | Citing Article:  D12-1067.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Riedel and Clarke (2006) showed that dependency parsing can be framed as Integer Linear Program (ILP), and efficiently solved using an off-the shelf optimizer if a cutting plane approach is used.</S> | Reference Offset:  ['0','206'] | Reference Text:  <S sid = 0 ssid = >Incremental Integer Linear Programming For Non-Projective Dependency Parsing</S><S sid = 206 ssid = >While previous approaches which use ILP for decoding have solved each integer linear program in one run, we incrementally add constraints and solve the resulting program until no more constraints are violated.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 10 | Reference Article:  W06-1616.txt | Citing Article:  D12-1067.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Compared to the representation Riedel and Clarke (2006), this bound has the benefit a small polynomial number of constraints.</S> | Reference Offset:  ['177','200'] | Reference Text:  <S sid = 177 ssid = >Also, only a small number of sentences take longer than two minutes to parse.</S><S sid = 200 ssid = >Thus other applications may benefit from it.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 11 | Reference Article:  W06-1616.txt | Citing Article:  D12-1067.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Our formulation is inspired by Martins et al 2009, and hence uses fewer constraints than Riedel and Clarke (2006).</S> | Reference Offset:  ['75','199'] | Reference Text:  <S sid = 75 ssid = >However, global constraints cannot be incorporated into the CLE algorithm (McDonald et al., 2005b).</S><S sid = 199 ssid = >Our approach uses a generic algorithm to solve a complex task.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 12 | Reference Article:  W06-1616.txt | Citing Article:  P11-1062.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >We suggest scaling techniques that allow to optimally learn such graphs over a large set of typed predicates by first decomposing nodes into components and then applying incremental ILP (Riedel and Clarke, 2006).</S> | Reference Offset:  ['42','204'] | Reference Text:  <S sid = 42 ssid = >It has the advantage of being more efficient to learn and parse.</S><S sid = 204 ssid = >We hope that the incremental approach will allow exact MT decoding for longer sentences.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 13 | Reference Article:  W06-1616.txt | Citing Article:  P11-1062.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Another solution for scaling ILP is to employ incremental ILP, which has been used in dependency parsing (Riedel and Clarke, 2006).</S> | Reference Offset:  ['57','180'] | Reference Text:  <S sid = 57 ssid = >This is not the case when using ILP.</S><S sid = 180 ssid = >This could be used to justify using the CLE algorithm to find a initial solution as starting point for the ILP solver (see Section 6).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 14 | Reference Article:  W06-1616.txt | Citing Article:  C10-1011.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >For instance, to improve the accuracy further, more global constrains capturing the subcategorization correct could be integrated as in Riedel and Clarke (2006).</S> | Reference Offset:  ['147','153'] | Reference Text:  <S sid = 147 ssid = >An important question to answer when using global constraints is: How much of a performance boost is gained when using global constraints?</S><S sid = 153 ssid = >The baseline system (no additional constraints) gives an unlabelled accuracy of 84.6% and labelled accuracy of 88.9%.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 15 | Reference Article:  W06-1616.txt | Citing Article:  P09-1039.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Riedel and Clarke (2006) cast dependency parsing as an ILP, but efficient formulations remain an open problem.</S> | Reference Offset:  ['42','84'] | Reference Text:  <S sid = 42 ssid = >It has the advantage of being more efficient to learn and parse.</S><S sid = 84 ssid = >There are several explicit formulations of the MST problem as an integer linear program in the literature (Williams, 2002).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 16 | Reference Article:  W06-1616.txt | Citing Article:  P09-1039.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >If it is extended to labeled parsing (a straightforward extension), our formulation fully subsumes that of Riedel and Clarke (2006), since it allows using the same hard constraints and features while keeping the ILP polynomial in size.</S> | Reference Offset:  ['57','192'] | Reference Text:  <S sid = 57 ssid = >This is not the case when using ILP.</S><S sid = 192 ssid = >We can model higher order features by using an extended set of variables and a modified objective function.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 17 | Reference Article:  W06-1616.txt | Citing Article:  P09-1039.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Rather than adding exponentially many constraints, one for each potential cycle (like Riedel and Clarke, 2006), we equivalently replace condition 3 by 3.</S> | Reference Offset:  ['18','90'] | Reference Text:  <S sid = 18 ssid = >Instead of adding all the constraints we wish to capture to the formulation, we first solve the program with a fraction of the constraints.</S><S sid = 90 ssid = >Instead of adding constraints which forbid all possible cycles in advance (this would result in an exponential number of constraints) we first solve the problem without any cycle constraints.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 18 | Reference Article:  W06-1616.txt | Citing Article:  P09-1039.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >all of them state-of-the-art parsers based on non-arc-factored models: the second order model of McDonald and Pereira (2006), the hybrid model of Nivre and McDonald (2008), which combines a (labeled) transition-based and a graph based parser, and a refinement of the latter, due to Martins et al (2008), which attempts to approximate non-local features. We did not reproduce the model of Riedel and Clarke (2006) since the latter is tailored for labeled dependency parsing; however, experiments reported in that paper for Dutch (and extended to other languages in the CoNLL-X task) suggest that their model performs worse than our three baselines.</S> | Reference Offset:  ['7','21'] | Reference Text:  <S sid = 7 ssid = >Strong assumptions are also made in the case of McDonald et al.â€™s (2005b) non-projective dependency parsing model.</S><S sid = 21 ssid = >We apply this dependency parsing approach to Dutch due to the languageâ€™s non-projective nature, and take the parser of McDonald et al. (2005b) as a starting point for our model.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 19 | Reference Article:  W06-1616.txt | Citing Article:  P09-1039.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >The average runtime (across all languages) is 0.632 seconds per sentence, which is in line with existing higher-order parsers and is much faster than the runtimes reported by Riedel and Clarke (2006).</S> | Reference Offset:  ['158','192'] | Reference Text:  <S sid = 158 ssid = >However, they use a subset of the CoNLL Alpino treebank with a higher average number of tokens per sentences and also evaluate control relations, thus results are not directly comparable.</S><S sid = 192 ssid = >We can model higher order features by using an extended set of variables and a modified objective function.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 20 | Reference Article:  W06-1616.txt | Citing Article:  D12-1102.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >The standard approach to framing dependency parsing as an integer linear program was introduced by (Riedel and Clarke, 2006), who converted the MST parser of (McDonald et al 2005) to use ILP for inference. The key idea is to build a complete graph consisting of tokens of the sentence where each edge is weighted by a learned scoring function.</S> | Reference Offset:  ['2','206'] | Reference Text:  <S sid = 2 ssid = >However, in certain applications, such as non-projective dependency parsing and machine translation, the complete formulation of the decoding problem as an integer linear program renders solving intractable.</S><S sid = 206 ssid = >While previous approaches which use ILP for decoding have solved each integer linear program in one run, we incrementally add constraints and solve the resulting program until no more constraints are violated.</S> | Discourse Facet:  NA | Annotator: Automatic


