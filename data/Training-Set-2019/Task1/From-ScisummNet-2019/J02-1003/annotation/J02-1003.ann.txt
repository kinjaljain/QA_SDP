Citance Number: 1 | Reference Article:  J02-1003.txt | Citing Article:  C04-1171.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Therefore, van Deemter (2002) has extended the set of descriptors to boolean combinations of attributes, including negations.</S> | Reference Offset:  ['61','149'] | Reference Text:  <S sid = 61 ssid = >A is the list of Attributes; L is the set of Attribute/Value combinations returned by the algorithm.</S><S sid = 149 ssid = >, Pn whose extension equals a given target set S (van Deemter 2000).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 2 | Reference Article:  J02-1003.txt | Citing Article:  W10-4224.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Recent extensions address some of its shortcomings, such as negated and disjoined properties (van Deemter, 2002) and an account of salience for generating contextually appropriate shorter REs (Krahmer and Theune, 2002).</S> | Reference Offset:  ['0','264'] | Reference Text:  <S sid = 0 ssid = >Generating Referring Expressions: Boolean Extensions Of The Incremental Algorithm</S><S sid = 264 ssid = >Moreover, they disregard shades of salience (unlike algorithms proposed in Krahmer and Theune [1999], Theune [2000]), relying instead on a simple dichotomy between those objects that are salient enough (which end up in the domain D) and those that are not (Reiter and Dale 2000, Section 5.4).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 3 | Reference Article:  J02-1003.txt | Citing Article:  W06-1410.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >The Context-Sensitive extension (Krahmer and Theune, 2002) is able to generate referring expressions for the most salient entity in a context; the Boolean Expressions algorithm (van Deemter, 2002) is able to derive expressions containing boolean operators, as in the cup that does not have a handle; and the Sets algorithm (van Deemter, 2002) extends the basic approach to references to sets, as in the red cups.</S> | Reference Offset:  ['0','169'] | Reference Text:  <S sid = 0 ssid = >Generating Referring Expressions: Boolean Extensions Of The Incremental Algorithm</S><S sid = 169 ssid = >Now that we are able to generate references to sets, let us move away from purely intersective descriptions, on to full Boolean combinations of properties.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 4 | Reference Article:  J02-1003.txt | Citing Article:  W05-1606.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Recently, algorithms have been applied to the identification of sets of objects rather than individuals [Bateman 1999, Stone 2000, Krahmer, v. Erk, and Verweg 2001], and the repertoire of descriptions has been extended to boolean combinations of attributes, including negations [van Deemter 2002].</S> | Reference Offset:  ['153','263'] | Reference Text:  <S sid = 153 ssid = >Stone 2000).</S><S sid = 263 ssid = >For example, they do not involve relational descriptions (Dale and Haddock 1991; Horacek 1997; Krahmer, van Erk, and Verleg 2001) or properties that are vague or context dependent (van Deemter 2000).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 5 | Reference Article:  J02-1003.txt | Citing Article:  W05-1606.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >This is because these operators appear only in embedded boolean combinations [van Deemter 2002], which are the basis for building larger varieties of expressions [Horacek 2004].</S> | Reference Offset:  ['0','98'] | Reference Text:  <S sid = 0 ssid = >Generating Referring Expressions: Boolean Extensions Of The Incremental Algorithm</S><S sid = 98 ssid = >Such descriptions appear to be quite natural.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 6 | Reference Article:  J02-1003.txt | Citing Article:  P04-1052.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Subsequent work on referring expression generation has expanded the logical framework to allow reference by negation (the dog that is not black) and references to multiple entities (the brown or black dogs) (van Deemter, 2002), explored different search algorithms for finding the minimal description (e.g., Horacek (2003)) and offered different representation frameworks like graph theory (Krahmer et al, 2003) as alternatives to AVMs.</S> | Reference Offset:  ['179','219'] | Reference Text:  <S sid = 179 ssid = >Two of the three properties in DOG n POODLE n BLACK are redundant, however.</S><S sid = 219 ssid = >If we modify the example by letting [[BLACK]] = {a, c} (rather than {a, b, c}) and S = {b, c, d, e} (rather than S = {a, b, d, e}), then the description L = {BLACK U POODLE} is found.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 7 | Reference Article:  J02-1003.txt | Citing Article:  C08-1055.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Transformation Rules: In connection with reference to sets, it has been proposed to use the Q-M algorithm (McCluskey,) to find the shortest formula equivalent to a given input formula (van Deemter, 2002).</S> | Reference Offset:  ['149','251'] | Reference Text:  <S sid = 149 ssid = >, Pn whose extension equals a given target set S (van Deemter 2000).</S><S sid = 251 ssid = >Lemma Let cp be a CNF formula whose longest union has a length of n (i.e., it conjoins n literals).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 8 | Reference Article:  J02-1003.txt | Citing Article:  D07-1011.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >GRE has been dominated by Dale and Reiter's (1995) Incremental Algorithm (IA), one version of which, generalised to deal with non-disjunctive plural references, is shown in Algorithm 1 (van Deemter, 2002).</S> | Reference Offset:  ['32','267'] | Reference Text:  <S sid = 32 ssid = >The Incremental Algorithm of Dale and Reiter (1995) singles out a target object from among some larger domain of entities.</S><S sid = 267 ssid = >In particular, we have shown Dale and Reiter’s (1995) Incremental Algorithm to be intersectively incomplete with respect to Attributes that have overlapping Values and (less surprisingly) in some situations where the class of properties is infinitely large.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 9 | Reference Article:  J02-1003.txt | Citing Article:  D07-1011.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Such a description would be returned by a generalised version of Algorithm 1 proposed by van Deemter (2002).</S> | Reference Offset:  ['61','64'] | Reference Text:  <S sid = 61 ssid = >A is the list of Attributes; L is the set of Attribute/Value combinations returned by the algorithm.</S><S sid = 64 ssid = >This version of the algorithm will be called D&RAtt.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 10 | Reference Article:  J02-1003.txt | Citing Article:  D07-1011.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Unlike van Deemter (2002), we only focus on disjunction, leaving negation aside.</S> | Reference Offset:  ['174','181'] | Reference Text:  <S sid = 174 ssid = >In the next two sections, we will investigate how negation and disjunction can be taken into account in GRE.</S><S sid = 181 ssid = >The present paper will focus on another approach to Boolean descriptions, which takes the Incremental Algorithm as its point of departure (van Deemter 2001).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 11 | Reference Article:  J02-1003.txt | Citing Article:  D07-1011.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Evaluation results showed that these principles are on the right track, with significantly better performance over a previous model (van Deemter, 2002).</S> | Reference Offset:  ['42','106'] | Reference Text:  <S sid = 42 ssid = >It is a “hillclimbing” algorithm, which finds better and better approximations of the target set {r} by accumulating more and more properties—hence the term Incremental.</S><S sid = 106 ssid = >Infinity of the set of distractors results in a different problem.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 12 | Reference Article:  J02-1003.txt | Citing Article:  W08-1107.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >For instance, the classical Dale and Reiter algorithms compute purely conjunctive formulas; van Deemter (2002) extends this language by adding the other propositional connectives, whereas Dale and Haddock (1991) extends it by allowing existential quantification.</S> | Reference Offset:  ['53','263'] | Reference Text:  <S sid = 53 ssid = >Reiter and Dale 2000).</S><S sid = 263 ssid = >For example, they do not involve relational descriptions (Dale and Haddock 1991; Horacek 1997; Krahmer, van Erk, and Verleg 2001) or properties that are vague or context dependent (van Deemter 2000).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 13 | Reference Article:  J02-1003.txt | Citing Article:  W08-1107.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Although we agree with van Deemter (2002) and others that the careful use of negation and disjunction can improve REs, these connectives must not be overused.</S> | Reference Offset:  ['89','174'] | Reference Text:  <S sid = 89 ssid = >None of this can be corrected, since the algorithm does not use backtracking.</S><S sid = 174 ssid = >In the next two sections, we will investigate how negation and disjunction can be taken into account in GRE.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 14 | Reference Article:  J02-1003.txt | Citing Article:  W06-1408.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Recently, algorithms have also been developed to the identification of sets of objects rather than individuals (Bateman 1999, Stone 2000, Krahmer, v. Erk, and Verweg 2001), and the repertoire of descriptions has been extended to boolean combinations of attributes, including negations (van Deemter 2002).</S> | Reference Offset:  ['153','263'] | Reference Text:  <S sid = 153 ssid = >Stone 2000).</S><S sid = 263 ssid = >For example, they do not involve relational descriptions (Dale and Haddock 1991; Horacek 1997; Krahmer, van Erk, and Verleg 2001) or properties that are vague or context dependent (van Deemter 2000).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 15 | Reference Article:  J02-1003.txt | Citing Article:  W06-1408.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >An exception to this method is the work by Paraboni and van Deemter (2002) who use hierarchical object representations to refer to parts of a book (figures, sections., etc.).</S> | Reference Offset:  ['80','292'] | Reference Text:  <S sid = 80 ssid = >Also, Values may derive from particular parts or aspects of an object; for example, if an object counts as METAL (PLASTIC) because it has some METAL (PLASTIC) parts, then it may be listed as both METAL and PLASTIC.</S><S sid = 292 ssid = >Recent work also highlights an interesting mirror image of GRE complexity: a logically superfluous property may make it easier for the reader to find the referent. van Deemter Generating Referring Expressions An interesting class of cases is explored in Paraboni (2000), which focuses on descriptions of document parts.</S> | Discourse Facet:  NA | Annotator: Automatic


