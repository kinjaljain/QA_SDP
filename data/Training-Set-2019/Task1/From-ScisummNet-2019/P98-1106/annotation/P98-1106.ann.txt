Citance Number: 1 | Reference Article:  P98-1106.txt | Citing Article:  P01-1029.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >It is possible to obtain a polynomial parser provided that we limit the number of nodes simultaneously involved in non-projective configurations (see Kahane et al 1998 for similar techniques).</S> | Reference Offset:  ['42','131'] | Reference Text:  <S sid = 42 ssid = >If there is no restriction on the lifting, the previous definition is not very interesting since we can in fact take any non-projective tree and lift all nodes to the root node and obtain a projective tree.</S><S sid = 131 ssid = >(No other options are possible.)</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 2 | Reference Article:  P98-1106.txt | Citing Article:  W04-1503.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >This formalism is based on previous work presented in (Kahane et al, 1998), which has been substantially reformulated in order to simplify it.</S> | Reference Offset:  ['9','60'] | Reference Text:  <S sid = 9 ssid = >In Section 4, we extend this formalism to handle pseudo-projectivity.</S><S sid = 60 ssid = >For a model of a DG based on tree-rewriting (in the spirit of Tree Adjoining Grammar (Joshi et al., 1975)), see (Nasr, 1995).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 3 | Reference Article:  P98-1106.txt | Citing Article:  W04-1503.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >We will extend our basic approach in the spirit of (Kahane et al, 1998) in future work.</S> | Reference Offset:  ['9','60'] | Reference Text:  <S sid = 9 ssid = >In Section 4, we extend this formalism to handle pseudo-projectivity.</S><S sid = 60 ssid = >For a model of a DG based on tree-rewriting (in the spirit of Tree Adjoining Grammar (Joshi et al., 1975)), see (Nasr, 1995).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 4 | Reference Article:  P98-1106.txt | Citing Article:  W04-1503.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Kahane et al (1998) present three different types of rules, for sub categorization, modification, and linear precedence.</S> | Reference Offset:  ['28','55'] | Reference Text:  <S sid = 28 ssid = >It can be noted that this domain of locality is equal to the domain of locality of sub-categorization rules.</S><S sid = 55 ssid = >The dependency rules are further subdivided into subcategorization rules (or s-rules) and modification rules (or m-rules).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 5 | Reference Article:  P98-1106.txt | Citing Article:  P01-1024.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >It is also related to the lifting rules of (Kahane et al, 1998), but where they choose to stipulate rules that license liftings, we opt instead for placing constraints on otherwise unrestricted climbing.</S> | Reference Offset:  ['43','55'] | Reference Text:  <S sid = 43 ssid = >We will therefore constrain the lifting by a set of rules, called lifting rules.</S><S sid = 55 ssid = >The dependency rules are further subdivided into subcategorization rules (or s-rules) and modification rules (or m-rules).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 6 | Reference Article:  P98-1106.txt | Citing Article:  E06-1010.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >The pseudo-projective grammar proposed by Kahane et al (1998) can be parsed in polynomial time and captures non-local dependencies through a form of gap-threading, but the structures generated by the grammar are strictly projective.</S> | Reference Offset:  ['0','32'] | Reference Text:  <S sid = 0 ssid = >Pseudo-Projectivity A Polynomially Parsable Non-Projective Dependency Grammar</S><S sid = 32 ssid = >The non projective structures found in linguistics represent a small subset of the potential non projective structures.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 7 | Reference Article:  P98-1106.txt | Citing Article:  C10-2013.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >With this conversion technique, output dependency trees are necessarily projective, and extracted dependencies are necessarily local to a phrase, which means that the automatically converted trees can be regarded as pseudo-projective approximations to the correct dependency trees (Kahane et al, 1998).</S> | Reference Offset:  ['30','34'] | Reference Text:  <S sid = 30 ssid = >Although most linguistic structures can be represented as projective trees, it is well known that projectivity is too strong a constraint for dependency trees, as shown by the example of Figure 2, which includes a non-projective arc (marked with a star).</S><S sid = 34 ssid = >In order to define pseudo-projectivity, we introduce an operation on dependency trees called lifting.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 8 | Reference Article:  P98-1106.txt | Citing Article:  W04-1510.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >This concept was introduced as lifting in (Kahane et al, 1998).</S> | Reference Offset:  ['97','103'] | Reference Text:  <S sid = 97 ssid = >The regular expression representing the lifting condition is enriched with a dot separating, on its left, the part of the lifting path which has already been introduced during the rewriting and on its right the part which is still to be introduced for the rewriting to be valid.</S><S sid = 103 ssid = >The situation of the dot at the right of the lifting condition indicates that C has been introduced by its syntactic governor although it has already been introduced by its linear governor earlier in the rewriting process.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 9 | Reference Article:  P98-1106.txt | Citing Article:  P08-1110.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >based: for example, those described by Lombardoand Lesmo (1996), Barbero et al (1998) and Kahane et al (1998) are tied to the formalizations of dependency grammar using context-free like rules described by Hays (1964) and Gaifman (1965).</S> | Reference Offset:  ['58','60'] | Reference Text:  <S sid = 58 ssid = >For example: 3We follow (Gaifman, 1965) throughout this paper by modeling a dependency grammar with a string-rewriting system.</S><S sid = 60 ssid = >For a model of a DG based on tree-rewriting (in the spirit of Tree Adjoining Grammar (Joshi et al., 1975)), see (Nasr, 1995).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 10 | Reference Article:  P98-1106.txt | Citing Article:  P08-1110.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >However, predictive grammar-based algorithms such as those of Lombardo and Lesmo (1996) and Kahane et al (1998) have operations which postulate rules and can not be defined in terms of dependency graphs, since they do not do any modifications to the graph.</S> | Reference Offset:  ['55','60'] | Reference Text:  <S sid = 55 ssid = >The dependency rules are further subdivided into subcategorization rules (or s-rules) and modification rules (or m-rules).</S><S sid = 60 ssid = >For a model of a DG based on tree-rewriting (in the spirit of Tree Adjoining Grammar (Joshi et al., 1975)), see (Nasr, 1995).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 11 | Reference Article:  P98-1106.txt | Citing Article:  W07-2216.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >In addition, the work of Kahane et al (1998) provides a polynomial parsing algorithm for a constrained class of non projective structures.</S> | Reference Offset:  ['30','32'] | Reference Text:  <S sid = 30 ssid = >Although most linguistic structures can be represented as projective trees, it is well known that projectivity is too strong a constraint for dependency trees, as shown by the example of Figure 2, which includes a non-projective arc (marked with a star).</S><S sid = 32 ssid = >The non projective structures found in linguistics represent a small subset of the potential non projective structures.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 12 | Reference Article:  P98-1106.txt | Citing Article:  P07-1122.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >The definition of non-projectivity can be found in Kahane et al (1998).</S> | Reference Offset:  ['0','22'] | Reference Text:  <S sid = 0 ssid = >Pseudo-Projectivity A Polynomially Parsable Non-Projective Dependency Grammar</S><S sid = 22 ssid = >The definition given here is borrowed from (Marcus, 1965) and (Robinson, 1970): Definition: An arc t- is projective if and only if for every y covered by y x+ .</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 13 | Reference Article:  P98-1106.txt | Citing Article:  P01-1021.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = ></S> | Reference Offset:  ['47','151'] | Reference Text:  <S sid = 47 ssid = >Every set of lifting rules defines a particular property of pseudo-projectivity by imposing particular constraints on the lifting.</S><S sid = 151 ssid = >The time complexity of the algorithm is therefore 0(GQn3+2ILI).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 14 | Reference Article:  P98-1106.txt | Citing Article:  P05-1013.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al, 1998) and encoding information about these lifts in arc labels.</S> | Reference Offset:  ['118','149'] | Reference Text:  <S sid = 118 ssid = >We can extend the bottom-up parser for GDG to a parser for PP-GDG in the following manner.</S><S sid = 149 ssid = >The maximum number of entries in each square of the parse matrix is 0(GQ4), where G is the number of rule-FSMs corresponding to LP rules in the grammar, Q is the maximum number of states in any of the rule-FSMs, and L is the maximum number of states that the lifting rules can be in (i.e., the number of lifting conditions in the grammar multiplied by the maximum number of dot positions of any lifting condition).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 15 | Reference Article:  P98-1106.txt | Citing Article:  P05-1013.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >We call this pseudo projective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al, 1998).</S> | Reference Offset:  ['0','34'] | Reference Text:  <S sid = 0 ssid = >Pseudo-Projectivity A Polynomially Parsable Non-Projective Dependency Grammar</S><S sid = 34 ssid = >In order to define pseudo-projectivity, we introduce an operation on dependency trees called lifting.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 16 | Reference Article:  P98-1106.txt | Citing Article:  P05-1013.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >The dependency graph in Figure 1 satisfies all the defining conditions above, but it fails to satisfy the condition of projectivity (Kahane et al, 1998).</S> | Reference Offset:  ['30','141'] | Reference Text:  <S sid = 30 ssid = >Although most linguistic structures can be represented as projective trees, it is well known that projectivity is too strong a constraint for dependency trees, as shown by the example of Figure 2, which includes a non-projective arc (marked with a star).</S><S sid = 141 ssid = >If, after the above repositioning of the dot and the linking up of all linear dependents to lifting conditions, there are still lifting conditions in LM such that the dot is at the beginning of the lifting condition, then no new entry is made in the parse matrix for n. 4.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 17 | Reference Article:  P98-1106.txt | Citing Article:  P05-1013.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Using the terminology of Kahane et al (1998), we say that jedna is the syntactic head of Z, while je is its linear head in the projectivized representation.</S> | Reference Offset:  ['37','90'] | Reference Text:  <S sid = 37 ssid = >We will say that the node x has been lifted from X+T (its syntactic governor) to X+Ti (its linear governor).</S><S sid = 90 ssid = >In order to capture pseudo-projectivity, we will interpret rules of the form (2) (for subcategorization of arguments by a head) and (4) (for selection of a head by an adjunct) as introducing syntactic dependents which may lift to a higher linear governor.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 18 | Reference Article:  P98-1106.txt | Citing Article:  P05-1013.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Unlike Kahane et al (1998), we do not regard a projectivized representation as the final target of the parsing process.</S> | Reference Offset:  ['69','110'] | Reference Text:  <S sid = 69 ssid = >A sample derivation is shown in Figure 3, with the sentential form representation on top and the corresponding tree representation below.</S><S sid = 110 ssid = >A sample derivation is shown in Figure 4, with the sentential form representation on top and the corresponding tree representation below.</S> | Discourse Facet:  NA | Annotator: Automatic


