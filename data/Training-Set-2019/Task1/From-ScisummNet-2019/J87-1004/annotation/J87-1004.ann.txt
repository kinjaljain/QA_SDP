Citance Number: 1 | Reference Article:  J87-1004.txt | Citing Article:  P90-1035.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = ></S> | Reference Offset:  ['93','276'] | Reference Text:  <S sid = 93 ssid = >This can be avoided by using a tree-structured stack, which is described in the following subsection.</S><S sid = 276 ssid = >Ron Kaplan, Martin Kay, Lauri Karttunen, and Stuart Shieber provided useful comments on the implementation of LFG and dag structure sharing.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 2 | Reference Article:  J87-1004.txt | Citing Article:  P90-1035.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >Similar to the work of Lang (1974) and Tomita (1987) extending LR parsers for arbitrary CFGs, the LR parsers for TAGs can be extended to solve by pseudo-parallelism the conflicts of moves.</S> | Reference Offset:  ['69','250'] | Reference Text:  <S sid = 69 ssid = >The pseudo-parallelism works as follows.</S><S sid = 250 ssid = >Despite the availability of left-to-right algorithms, surprisingly few on-line parsers exist.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 3 | Reference Article:  J87-1004.txt | Citing Article:  C94-1020.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >We developed a set of augmented context free grammar rules for general English syntactic analysis and the analyzer is implemented using Tomita LR parsing algorithm (Tomita, 1987).</S> | Reference Offset:  ['0','266'] | Reference Text:  <S sid = 0 ssid = >An Efficient Augmented-Context-Free Parsing Algorithm</S><S sid = 266 ssid = >Thus, morphological rules, as well as syntactic rules, are written in the augmented context-free grammar.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 4 | Reference Article:  J87-1004.txt | Citing Article:  D07-1130.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >The RASP parser is a generalized LR parser which builds a non-deterministic generalized LALR parse table from the grammar (Tomita, 1987).</S> | Reference Offset:  ['47','115'] | Reference Text:  <S sid = 47 ssid = >Figures 2.1 and 2.2 show an example of a non-LR grammar and its parsing table.</S><S sid = 115 ssid = >In this paper, however, we describe the algorithm as a generalized LR parsing algorithm only.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 5 | Reference Article:  J87-1004.txt | Citing Article:  P03-2003.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >a graph-structured stack (Tomita, 1987) was used to efficiently represent ambiguous index operations in a GIG stack.</S> | Reference Offset:  ['97','105'] | Reference Text:  <S sid = 97 ssid = >We call this a tree-structured stack.</S><S sid = 105 ssid = >However, we do not necessarily have to copy the whole stack: even after different parallel operations on the tree-structured stack, the bottom portion of the stack may remain the same.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 6 | Reference Article:  J87-1004.txt | Citing Article:  W07-2203.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >A context-free backbone is automatically derived from the unification grammar1 and a generalized or non-deterministic LALR(1) table is constructed from this backbone (Tomita, 1987).</S> | Reference Offset:  ['12','40'] | Reference Text:  <S sid = 12 ssid = >The algorithm is a generalized LR parsing algorithm, which precomputes an LR shift-reduce parsing table (possibly with multiple entries) from a given augmented context-free grammar.</S><S sid = 40 ssid = >The parsing table can be obtained automatically from a context-free phrase structure grammar, using an algorithm first developed by DeRemer (1969, 1971).</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 7 | Reference Article:  J87-1004.txt | Citing Article:  P94-1040.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >The parsers create parse forests (Tomita, 1987) that incorporate subtree sharing (in which identical sub-analyses are shared between differing superordinate analyses) and node packing (where sub analyses covering the same portion of input whose root categories are in a subsumption relationship are merged into a single node).</S> | Reference Offset:  ['124','136'] | Reference Text:  <S sid = 124 ssid = >This section describes two techniques for providing an efficient representation: subtree sharing and local ambiguity packing.</S><S sid = 136 ssid = >Such a node is called a packed node, and nodes before packing are called subnodes of the packed node.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 8 | Reference Article:  J87-1004.txt | Citing Article:  P94-1040.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >In this parser, the LALR (1) technique (Aho, Sethi Ullman, 1986) is used, in conjunction with a graph-structured stack (Tomita, 1987), adapting for unification-based parsing Kipps's (1989) Tomita-like recogniser that achieves polynomial complexity on input length through caching.</S> | Reference Offset:  ['54','110'] | Reference Text:  <S sid = 54 ssid = >The exact definition and operation of the LR parser can be found in Aho and Ullman (1977).</S><S sid = 110 ssid = >It is easy to show that the algorithm with the graph-structured stack does not parse any part of an input sentence more than once in the same way.</S> | Discourse Facet:  NA | Annotator: Automatic


Citance Number: 9 | Reference Article:  J87-1004.txt | Citing Article:  P10-1090.txt | Citation Marker Offset:  NA | Citation Marker: NA | Citation Offset: NA | Citation Text:  <S sid =  ssid = >A forest (Tomita, 1987) compactly encodes an exponential number of parse trees.</S> | Reference Offset:  ['27','122'] | Reference Text:  <S sid = 27 ssid = >Section 3 describes how to represent parse trees efficiently, so that all possible parse trees (the parse forest) take at most polynomial space as the ambiguity of a sentence grows exponentially.</S><S sid = 122 ssid = >Thus, one might notice that, even with an efficient parsing algorithm such as the one we described, the parser would take exponential time because exponential time would be required merely to print out all parse trees (parse forest).</S> | Discourse Facet:  NA | Annotator: Automatic


